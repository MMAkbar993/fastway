<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>FASTWAY - Standing</title>
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="css/style standing Copie.css" />
</head>

<body>
    <header>
        <div class="navbar">
            <a href="index.html" class="logo">
                <div class="logo-container">
                    <img src="Fastwaylogo2.png" alt="FASTWAY Logo">
                </div>
            </a>
            <nav class="nav-links">
                <a href="standing Copie.html">STANDING</a>
                <a href="playoff.html">PLAYOFF</a>
                <a href="driverlist.html">DRIVER LIST</a>
                <a href="halloffame.html">HALL OF FAME</a>
                <a href="award.html">AWARD</a>
            </nav>
        </div>
        <div class="navbar-underline"></div>
    </header>


    <main class="standing-page">
        <div class="top-line">
            <h1>Fastway A serie standing</h1>
            <div class="race-buttons">
                <button class="btn start-calif">START CALIF</button>
                <button id="startRaceBtn" class="btn start-race">START RACE</button>
            </div>
            <div class="vertical-divider"></div>
            <div class="top-buttons-wrapper">
                <div class="serie-buttons">
                    <button class="btn btn-blue" id="btn-a">A SERIE</button>
                    <button class="btn btn-red" id="btn-b">B SERIE</button>
                </div>
            </div>
        </div>

        <div class="title-underline"></div>

        <div class="column-header">
            <div>Pos</div>
            <div>No.</div>
            <div>Car</div>
            <div>Point (Calif)</div>
            <div>Win</div>
            <div>CH Win</div>
            <div>Best Time</div>
            <div>Win%</div>
            <div>Total</div>
            <div class="last-time" style="display:none;">Last Time</div>
        </div>

        <div id="serie-a">
            <div class="column-row">
                <div>1</div>
                <div>914</div>
                <div>Time Track</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>2</div>
                <div></div>
                <div>Delorean</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>3</div>
                <div></div>
                <div>Stinger GT</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>4</div>
                <div>3</div>
                <div>DRIFTSTA</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>5</div>
                <div>52</div>
                <div>Erik's Rod</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>6</div>
                <div>2</div>
                <div>Hight Voltage</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>7</div>
                <div></div>
                <div>WHAT-4-2</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>8</div>
                <div></div>
                <div>COUNT MUSCULA</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>9</div>
                <div>32</div>
                <div>Glory Chaser</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>10</div>
                <div></div>
                <div>620</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>11</div>
                <div></div>
                <div>'69 Mustang Boss 302</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>12</div>
                <div>4</div>
                <div>'09 Focus RS</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>13</div>
                <div></div>
                <div>240Z</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>14</div>
                <div></div>
                <div>'69 COPO Camaro</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>15</div>
                <div></div>
                <div>'69 Camaro</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>16</div>
                <div>23</div>
                <div>LB Super Silvia S15</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>17</div>
                <div>8</div>
                <div>Corvette C8.R</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>18</div>
                <div></div>
                <div>Toyota 2000GT</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>19</div>
                <div>02</div>
                <div>'16 Cadillac ATS-VR</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>20</div>
                <div></div>
                <div>'69 CamaroB</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>21</div>
                <div>29</div>
                <div>Roder Dodger</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>22</div>
                <div>5</div>
                <div>Blade Raider</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>23</div>
                <div></div>
                <div>El Segundo Coupe</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>24</div>
                <div>70</div>
                <div>Chevy Chevelle SS</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>25</div>
                <div>54</div>
                <div>Skylines GTR</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>26</div>
                <div></div>
                <div>Leaf Nismo</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>27</div>
                <div>426</div>
                <div>Challenger Drift</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>28</div>
                <div></div>
                <div>'69 Charger 500</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
        </div>

        <div id="serie-b" class="serie-b hidden">
            <div class="column-row">
                <div>1</div>
                <div></div>
                <div>Motor Max Truck</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>2</div>
                <div></div>
                <div>'72 Stingray con</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>3</div>
                <div>8</div>
                <div>Formula8r</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>4</div>
                <div></div>
                <div>COPO Camaro Drag</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>5</div>
                <div></div>
                <div>'07 Mustang</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>6</div>
                <div>73</div>
                <div>'73 BMW CSL</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>7</div>
                <div>70</div>
                <div>Pontiac FirebirdB</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>8</div>
                <div></div>
                <div>RIP ROD</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>9</div>
                <div></div>
                <div>'62 Corvette</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>10</div>
                <div>4</div>
                <div>'10 Chevy Impala</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>11</div>
                <div>54</div>
                <div>Fairlandy 2000</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>12</div>
                <div></div>
                <div>Ferrari Scuderia</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>13</div>
                <div>12</div>
                <div>Limited Grip</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>14</div>
                <div>9</div>
                <div>Ford GT40 Mk.IV</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>15</div>
                <div>04</div>
                <div>Ford GT-40</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>16</div>
                <div>5</div>
                <div>THE GOV'NER</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>17</div>
                <div></div>
                <div>Dune it Up</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>18</div>
                <div>3</div>
                <div>Bone Shaker</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>19</div>
                <div>52</div>
                <div>DAVancenator</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>20</div>
                <div>06</div>
                <div>M16</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>21</div>
                <div></div>
                <div>Plymouth Barracuda</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>22</div>
                <div></div>
                <div>Lotus Emira</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>23</div>
                <div>100</div>
                <div>Bentley Continental</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>24</div>
                <div></div>
                <div>70 Camaro</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>25</div>
                <div>20</div>
                <div>CRUISE BRUISER</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>26</div>
                <div></div>
                <div>McLaren Senna</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>27</div>
                <div></div>
                <div>ND</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="column-row">
                <div>28</div>
                <div></div>
                <div>ND2</div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
        </div>

    </main>

    <div class="admin-buttons">
        <button id="undoQualifBtn">Annuler dernière qualification</button>
        <button id="resetRaceBtn">Recommencer les qualification</button>
        <button id="resetSeasonBtn">Redémarrer la saison</button>
    </div>

    <script>
        const serieA = document.getElementById("serie-a");
        const serieB = document.getElementById("serie-b");
        const title = document.querySelector(".top-line h1");
        const btnA = document.querySelector("#btn-a");
        const btnB = document.querySelector("#btn-b");
        btnA.addEventListener("click", () => {
            title.textContent = "FASTWAY A serie standing";
            serieA.classList.remove("hidden");
            serieB.classList.add("hidden");
            btnA.classList.add("active");
            btnB.classList.remove("active");
        });

        btnB.addEventListener("click", () => {
            title.textContent = "FASTWAY B serie standing";
            serieA.classList.add("hidden");
            serieB.classList.remove("hidden");
            btnB.classList.add("active");
            btnA.classList.remove("active");
        });

        window.onload = function () {
            btnA.click();
        };
    </script>

    <script>
        /* ----------script start calif ---------- */
        /* ---------- données / état ---------- */
        let qualifState = {
            serie: "A",              // "A" ou "B"
            inProgress: false,
            remainingCarsA: [],
            remainingCarsB: [],
            finishedA: false,
            finishedB: false,
            carTimes: {},
        };

        // Clés pour gérer l'alternance Qualif <-> Course
        const PHASE_KEY_PREFIX = "fastway_phase_"; // ex: fastway_phase_A

        let carTimes = {};
        let qualifDone = false;
        const oldSavedTimes = localStorage.getItem("fastwayCarTimes");
        if (oldSavedTimes) {
            try { carTimes = JSON.parse(oldSavedTimes); } catch (e) { carTimes = {}; }
        }

        const qualifhistory = [];
        let remainingCarsA = [];
        let remainingCarsB = [];

        const startCalifBtn = document.querySelector(".start-calif");
        const undoQualifBtn = document.getElementById("undoQualifBtn");
        const resetRaceBtn = document.getElementById("resetRaceBtn");
        const QUALIF_STATE_KEY = "fastway_qualif_state_v2";

        let finishedA = false;
        let finishedB = false;

        // index colonne "Point Calif"
        const COL_POINT_CALIF = 3;

        /* ---------- utilitaires ---------- */
        window.addEventListener("beforeunload", (event) => {
            const state = typeof getCurrentState === 'function' ? getCurrentState() : {};
            const isActive =
                state.qualifyingInProgress ||
                state.duelInProgress ||
                state.raceInProgress ||
                state.califInProgress;

            if (isActive) {
                event.preventDefault();
                event.returnValue = "Attention ! Vous risquez de perdre votre progression actuelle.";
            }
        });

        /* ---------- NOUVELLE FONCTION D'ALERTE STYLE FASTWAY ---------- */
        function showFastwayAlert(message, title = "ATTENTION") {
            // 1. Nettoyage des anciens modals
            document.querySelectorAll(".modal-overlay").forEach(m => m.remove());

            // 2. Overlay
            const modal = document.createElement("div");
            modal.className = "modal-overlay";
            Object.assign(modal.style, {
                position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.8)',
                display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10000, // zIndex très haut
                backdropFilter: 'blur(5px)', opacity: '0', transition: 'opacity 0.2s ease'
            });

            // 3. Wrapper LED (Le contour animé)
            const wrapper = document.createElement("div");
            Object.assign(wrapper.style, {
                position: 'relative', borderRadius: '18px', padding: '3px',
                background: 'linear-gradient(90deg, #ff003c, #0077ff, #ff003c)', backgroundSize: '300% 300%',
                boxShadow: '0 0 25px rgba(255,0,60,0.5), 0 0 40px rgba(0,120,255,0.4)',
                animation: 'ledPulse 3.5s ease-in-out infinite, ledGradient 6s linear infinite, shake 0.4s ease', // Ajout du shake à l'ouverture
                transform: 'scale(0.9)', transition: 'transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
                maxWidth: '90%'
            });

            // 4. Contenu
            const modalContent = document.createElement("div");
            Object.assign(modalContent.style, {
                background: '#1a1a1a', borderRadius: '15px', padding: '30px',
                minWidth: '320px', maxWidth: '450px',
                fontFamily: "'Poppins', sans-serif", color: '#fff', textAlign: 'center',
                display: 'flex', flexDirection: 'column', gap: '15px'
            });

            // Le message accepte le HTML (pour les sauts de ligne <br>)
            modalContent.innerHTML = `
        <h2 style="margin: 0; font-weight: 800; letter-spacing: 1px; font-size: 22px; text-transform: uppercase; color: #ff003c; text-shadow: 0 0 10px rgba(255,0,60,0.3);">
            ${title}
        </h2>
        <div style="font-size: 15px; line-height: 1.5; color: #ddd;">
            ${message.replace(/\n/g, '<br>')}
        </div>
        <div style="margin-top: 10px;">
            <button id="alertCloseBtn" style="
                padding: 10px 25px; border: none; border-radius: 8px;
                background: linear-gradient(135deg, #333, #111); color: #fff;
                border: 1px solid #444; font-weight: bold; cursor: pointer;
                font-family: 'Poppins', sans-serif; transition: all 0.2s;
                box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            ">D'ACCORD</button>
        </div>
    `;

            wrapper.appendChild(modalContent);
            modal.appendChild(wrapper);
            document.body.appendChild(modal);

            // Focus sur le bouton pour fermer avec Entrée
            const btn = modalContent.querySelector("#alertCloseBtn");
            btn.focus();

            // Animation d'entrée
            requestAnimationFrame(() => {
                modal.style.opacity = '1';
                wrapper.style.transform = 'scale(1)';
            });

            // Logique de fermeture
            const closeModal = () => {
                modal.style.opacity = '0';
                wrapper.style.transform = 'scale(0.9)';
                setTimeout(() => modal.remove(), 200);
            };

            btn.addEventListener("click", closeModal);
            btn.addEventListener("mouseover", () => { btn.style.borderColor = "#fff"; btn.style.background = "#444"; });
            btn.addEventListener("mouseout", () => { btn.style.borderColor = "#444"; btn.style.background = "linear-gradient(135deg, #333, #111)"; });

            modal.addEventListener("click", (e) => { if (e.target === modal) closeModal(); });
            window.addEventListener("keydown", function handler(e) {
                if (e.key === "Enter" || e.key === "Escape") {
                    closeModal();
                    window.removeEventListener("keydown", handler);
                }
            });

            // Injection styles si manquant (sécurité)
            if (!document.getElementById("modal-styles")) {
                const style = document.createElement("style");
                style.id = "modal-styles";
                style.textContent = `
            @keyframes ledGradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
            @keyframes ledPulse { 0%, 100% { box-shadow: 0 0 20px rgba(255,0,60,0.4), 0 0 30px rgba(0,120,255,0.3); } 50% { box-shadow: 0 0 35px rgba(255,0,60,0.6), 0 0 50px rgba(0,120,255,0.5); } }
            @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        `;
                document.head.appendChild(style);
            }
        }

        function saveQualifState() {
            try {
                qualifState.remainingCarsA = remainingCarsA;
                qualifState.remainingCarsB = remainingCarsB;
                qualifState.finishedA = finishedA;
                qualifState.finishedB = finishedB;
                qualifState.carTimes = carTimes;
                localStorage.setItem(QUALIF_STATE_KEY, JSON.stringify(qualifState));
            } catch (e) {
                console.warn("Erreur de sauvegarde qualification:", e);
            }
        }

        function loadQualifState() {
            try {
                const raw = localStorage.getItem(QUALIF_STATE_KEY);
                if (!raw) return;
                const s = JSON.parse(raw);
                qualifState = { ...qualifState, ...s };
                remainingCarsA = s.remainingCarsA || [];
                remainingCarsB = s.remainingCarsB || [];
                finishedA = s.finishedA || false;
                finishedB = s.finishedB || false;
                carTimes = s.carTimes || {};
            } catch (e) {
                console.warn("Erreur de chargement qualification:", e);
            }
        }

        function saveAllData() {
            const rows = Array.from(document.querySelectorAll(".column-row"));
            const arr = rows.map(row => ({
                name: row.children[2]?.textContent.trim() || "",
                points: row.children[COL_POINT_CALIF]?.textContent || "0",
                wins: row.children[4]?.textContent || "0",
                chWins: row.children[5]?.textContent || "0",
                bestTime: row.children[6]?.textContent || ""
            }));

            const meta = { carTimes: {}, carPoints: {} };
            for (const row of rows) {
                const name = row.children[2]?.textContent.trim();
                if (!name) continue;
                const lt = row.querySelector(".last-time");
                if (lt && lt.textContent) meta.carTimes[name] = lt.textContent;
                meta.carPoints[name] = parseInt(row.children[COL_POINT_CALIF]?.textContent || "0", 10) || 0;
            }

            localStorage.setItem("fastwayAllData", JSON.stringify(arr));
            localStorage.setItem("fastwayAllMeta", JSON.stringify(meta));
            localStorage.setItem("fastwayCarTimes", JSON.stringify(carTimes));
        }

        function loadAllData() {
            const rawMeta = localStorage.getItem("fastwayAllMeta");
            if (rawMeta) {
                try {
                    const meta = JSON.parse(rawMeta);
                    for (const row of Array.from(document.querySelectorAll(".column-row"))) {
                        const name = row.children[2]?.textContent.trim();
                        if (!name) continue;
                        if (meta.carTimes && meta.carTimes[name]) {
                            let lt = row.querySelector(".last-time");
                            if (!lt) {
                                lt = document.createElement("div");
                                lt.classList.add("last-time");
                                lt.style.display = "none";
                                row.appendChild(lt);
                            }
                            lt.textContent = meta.carTimes[name];
                        }
                        if (meta.carPoints && typeof meta.carPoints[name] !== "undefined") {
                            if (row.children[COL_POINT_CALIF]) row.children[COL_POINT_CALIF].textContent = String(meta.carPoints[name]);
                        }
                    }
                } catch (e) { console.warn("fastwayAllMeta invalide :", e); }
            }

            const rawArr = localStorage.getItem("fastwayAllData");
            if (rawArr) {
                try {
                    const arr = JSON.parse(rawArr);
                    if (Array.isArray(arr)) {
                        for (const row of Array.from(document.querySelectorAll(".column-row"))) {
                            const name = row.children[2]?.textContent.trim();
                            if (!name) continue;
                            const saved = arr.find(r => r.name === name);
                            if (saved) {
                                if (row.children[COL_POINT_CALIF]) row.children[COL_POINT_CALIF].textContent = saved.points || "0";
                                if (row.children[4]) row.children[4].textContent = saved.wins || "0";
                                if (row.children[5]) row.children[5].textContent = saved.chWins || "0";
                                if (row.children[6]) row.children[6].textContent = saved.bestTime || "";
                            }
                        }
                    }
                } catch (e) { console.warn("fastwayAllData invalide :", e); }
            }

            const rawCarTimes = localStorage.getItem("fastwayCarTimes");
            if (rawCarTimes) {
                try {
                    const ct = JSON.parse(rawCarTimes);
                    for (const row of Array.from(document.querySelectorAll(".column-row"))) {
                        const name = row.children[2]?.textContent.trim();
                        if (!name) continue;
                        if (ct[name] && row.children[6]) row.children[6].textContent = ct[name];
                    }
                    carTimes = Object.assign({}, carTimes, JSON.parse(rawCarTimes));
                } catch (e) { /* ignore */ }
            }
        }

        function restoreTotalPoints() {
            const rows = Array.from(document.querySelectorAll(".column-row"));
            for (const row of rows) {
                const pointsText = (row.children[COL_POINT_CALIF] && row.children[COL_POINT_CALIF].textContent) ? row.children[COL_POINT_CALIF].textContent.trim() : "0";
                const points = parseInt(pointsText.replace(/\D/g, ''), 10) || 0;
                if (row.children[COL_POINT_CALIF]) row.children[COL_POINT_CALIF].textContent = String(points);

                const wins = parseInt((row.children[4] && row.children[4].textContent) || "0", 10) || 0;
                const total = (wins * 10) + points;
                if (row.children[8]) row.children[8].textContent = String(total);
            }
        }

        function timeToNumber(timeStr) {
            if (!timeStr || /^dnf$/i.test(timeStr)) return Infinity;
            return parseFloat(timeStr.replace(",", "."));
        }

        function shuffle(array) {
            let m = array.length, t, i;
            while (m) {
                i = Math.floor(Math.random() * m--);
                t = array[m];
                array[m] = array[i];
                array[i] = t;
            }
            return array;
        }

        function normalizeTime(rawTime) {
            if (!rawTime) return "";
            let t = rawTime.trim().replace(",", ".");
            if (/^dnf$/i.test(t)) return "DNF";
            if (/^\d{2}\.\d{3}$/.test(t) && t.startsWith("0")) t = t.substring(1);
            return t;
        }

        const savedAllDataRaw = (() => {
            try {
                return JSON.parse(localStorage.getItem("fastwayAllData"));
            } catch (e) {
                return null;
            }
        })();

        const savedAllData = Array.isArray(savedAllDataRaw)
            ? savedAllDataRaw
            : (savedAllDataRaw && typeof savedAllDataRaw === "object"
                ? Object.values(savedAllDataRaw)
                : []);

        console.debug("savedAllData (normalized):", savedAllData);


        /* ---------- initialisation ---------- */
        window.addEventListener("DOMContentLoaded", () => {
            loadQualifState();
            loadAllData();

            if (qualifState.inProgress) {
                const serieVisible = qualifState.serie;
                const remaining = serieVisible === "A" ? remainingCarsA : remainingCarsB;
                if (remaining.length > 0) {
                    console.log(`Reprise qualification série ${serieVisible} (${remaining.length} voitures restantes)`);
                }
            }

            for (const row of Array.from(document.querySelectorAll(".column-row"))) {
                if (!row.querySelector(".last-time")) {
                    const d = document.createElement("div");
                    d.className = "last-time";
                    d.style.display = "none";
                    row.appendChild(d);
                }
            }

            const rows = Array.from(document.querySelectorAll(".column-row"));
            for (const row of rows) {
                const carName = row.children[2]?.textContent.trim();
                if (carTimes[carName] && row.children[6]) row.children[6].textContent = carTimes[carName];
            }

            finishedA = localStorage.getItem("finishedA") === "true";
            finishedB = localStorage.getItem("finishedB") === "true";

            const savedRemainingA = localStorage.getItem("remainingCarsA");
            if (savedRemainingA) remainingCarsA = JSON.parse(savedRemainingA);

            const savedRemainingB = localStorage.getItem("remainingCarsB");
            if (savedRemainingB) remainingCarsB = JSON.parse(savedRemainingB);

            finishedA = localStorage.getItem("finishedA") === "true";
            finishedB = localStorage.getItem("finishedB") === "true";

            if (!localStorage.getItem("fastway_benchmark_A")) saveRankBenchmark('A');
            if (!localStorage.getItem("fastway_benchmark_B")) saveRankBenchmark('B');

            restoreTotalPoints();
            updateMainTable();
        });


        /* ---------- tableau standing ---------- */
        function updateMainTable(skipWinPct = true) {
            try {
                const rows = Array.from(document.querySelectorAll(".column-row"));

                // ... (Récupération des données existante inchangée) ...
                let savedAllData = [];
                try {
                    const raw = JSON.parse(localStorage.getItem("fastwayAllData") || "[]");
                    savedAllData = Array.isArray(raw) ? raw : (raw && typeof raw === "object" ? Object.values(raw) : []);
                } catch (e) { savedAllData = []; }

                // Mise à jour des données brutes (Points, Wins, etc.)
                rows.forEach((row) => {
                    const getText = (i) => (row.children[i] && row.children[i].textContent) ? row.children[i].textContent.trim() : "";
                    const points = parseInt(getText(COL_POINT_CALIF).replace(/\D/g, '')) || 0;
                    const wins = parseInt(getText(4)) || 0;

                    let lossCell = row.querySelector(".loss");
                    if (!lossCell) {
                        lossCell = document.createElement("div");
                        lossCell.className = "loss";
                        lossCell.style.display = "none";
                        row.appendChild(lossCell);
                    }
                    const carName = getText(2);
                    const savedRow = savedAllData.find(r => r.name === carName) || {};
                    let losses = parseInt(lossCell.textContent) || parseInt(savedRow.losses) || 0;
                    if (!Number.isFinite(losses)) losses = 0;
                    lossCell.textContent = String(losses);

                    if (!skipWinPct && row.children[7]) {
                        const totalRaces = wins + losses;
                        let winPctText = "--";
                        if (totalRaces > 0) {
                            const winPct = (wins / totalRaces) * 100;
                            winPctText = Number.isFinite(winPct) ? winPct.toFixed(2).replace(/\.?0+$/, '') + "%" : "--";
                        }
                        row.children[7].textContent = winPctText;
                    }

                    const total = (wins * 10) + points;
                    if (row.children[8]) row.children[8].textContent = String(total);
                });

                // Fonction de tri et d'affichage du DELTA
                const sortSeries = (container, serieName) => {
                    if (!container) return;
                    const rowsArr = Array.from(container.querySelectorAll(".column-row"));
                    rowsArr.forEach((r, i) => { if (!r.dataset.rankId) r.dataset.rankId = i; });

                    // 1. TRI
                    rowsArr.sort((a, b) => {
                        const totalA = parseInt((a.children[8]?.textContent) || "0", 10);
                        const totalB = parseInt((b.children[8]?.textContent) || "0", 10);
                        if (totalB !== totalA) return totalB - totalA;
                        return (parseInt(a.dataset.rankId) || 0) - (parseInt(b.dataset.rankId) || 0);
                    });

                    // 2. Chargement du Benchmark (Ancien classement)
                    const benchmarkRaw = localStorage.getItem(`fastway_benchmark_${serieName}`);
                    const benchmark = benchmarkRaw ? JSON.parse(benchmarkRaw) : {};

                    // 3. Affichage Rank + Delta
                    rowsArr.forEach((r, i) => {
                        const newRank = i + 1;
                        const carName = r.children[2]?.textContent.trim();
                        const oldRank = benchmark[carName]; // Peut être undefined si nouvelle voiture

                        let deltaHTML = "";

                        if (oldRank) {
                            const diff = oldRank - newRank; // Ex: Était 5, Maint 2 => 5-2 = +3 (Gain)

                            if (diff > 0) {
                                // Gain de place (Vert)
                                deltaHTML = `<span class="delta-indicator delta-up">▲ +${diff}</span>`;
                            } else if (diff < 0) {
                                // Perte de place (Rouge)
                                deltaHTML = `<span class="delta-indicator delta-down">▼ ${diff}</span>`;
                            } else {
                                // Pas de changement (Vide ou tiret)
                                deltaHTML = `<span class="delta-indicator delta-neutral"></span>`;
                            }
                        } else {
                            // Pas d'historique
                            deltaHTML = `<span class="delta-indicator delta-neutral"></span>`;
                        }

                        // Injection dans la première colonne (Pos)
                        if (r.children[0]) {
                            r.children[0].innerHTML = `
                <div class="pos-cell-content">
                    ${deltaHTML}
                    <span class="rank-number">${newRank}</span>
                </div>
            `;
                        }

                        container.appendChild(r);
                    });
                };

                // Tri des séries
                sortSeries(serieA, 'A');
                sortSeries(serieB, 'B');

                saveAllData();
            } catch (e) {
                console.error("Erreur dans updateMainTable :", e);
            }
        }

        /* ---------- attribution points & MODAL RECAP STYLISÉ ---------- */
        function assignQualifPointsForSeries(serieElement) {
            if (!serieElement) return;

            const results = Array.from(serieElement.querySelectorAll(".column-row"))
                .map(row => {
                    const name = row.children[2]?.textContent.trim();
                    let lastTimeCell = row.querySelector(".last-time");
                    if (!lastTimeCell) {
                        lastTimeCell = document.createElement("div");
                        lastTimeCell.className = "last-time";
                        lastTimeCell.style.display = "none";
                        row.appendChild(lastTimeCell);
                    }
                    const timeStr = (lastTimeCell.textContent || "").trim();
                    const timeNum = timeToNumber(timeStr);
                    return { row, name, timeStr, timeNum };
                })
                .sort((a, b) => a.timeNum - b.timeNum);

            let currentPos = 1;
            for (let i = 0; i < results.length;) {
                let j = i + 1;
                while (j < results.length && results[j].timeNum === results[i].timeNum) j++;
                const groupCount = j - i;
                const pts = currentPos <= 10 ? (11 - currentPos) : 0;

                for (let k = i; k < j; k++) {
                    if (results[k].row && results[k].row.children[COL_POINT_CALIF]) {
                        const previous = parseInt(results[k].row.children[COL_POINT_CALIF].textContent, 10) || 0;
                        results[k].row.children[COL_POINT_CALIF].textContent = previous + pts;
                    }
                    results[k].displayPos = currentPos;
                    results[k].qualifPts = pts;
                }

                currentPos += groupCount;
                i = j;
            }

            saveAllData();

            const serieName = (serieElement === serieA) ? 'A' : 'B';
            saveRankBenchmark(serieName);

            // --- AJOUT CRITIQUE ICI ---
            // On force les variables à TRUE maintenant que les points sont calculés
            if (serieName === 'A') {
                qualifA_done = true;
                finishedA = true;
                // On assure le localStorage direct au cas où saveRaceState échoue
                localStorage.setItem("finishedA", "true");
            } else {
                qualifB_done = true;
                finishedB = true;
                localStorage.setItem("finishedB", "true");
            }

            // On sauvegarde l'état global (qui contient maintenant qualifA_done = true)
            saveRaceState();
            // --------------------------

            // 2. Nettoyage des anciens modals (Le reste de ton code pour le modal...)
            document.querySelectorAll(".modal-overlay").forEach(m => m.remove());

            const modal = document.createElement("div");
            modal.className = "modal-overlay";
            Object.assign(modal.style, {
                position: "fixed", inset: 0, background: "rgba(0,0,0,0.85)",
                display: "flex", alignItems: "center", justifyContent: "center", zIndex: 9999,
                backdropFilter: "blur(5px)", opacity: "0", transition: "opacity 0.3s ease"
            });

            const wrapper = document.createElement("div");
            Object.assign(wrapper.style, {
                position: "relative", borderRadius: "18px", padding: "3px",
                background: "linear-gradient(90deg,#ff003c,#0077ff,#ff003c)", backgroundSize: "300% 300%",
                boxShadow: "0 0 25px rgba(255,0,60,0.4),0 0 40px rgba(0,120,255,0.3)",
                animation: "ledPulse 3.5s ease-in-out infinite,ledGradient 6s linear infinite",
                transform: "scale(0.9)", transition: "transform 0.3s cubic-bezier(0.175,0.885,0.32,1.275)",
                maxHeight: "90vh", display: "flex", flexDirection: "column"
            });

            const modalContent = document.createElement("div");
            Object.assign(modalContent.style, {
                background: "#1a1a1a", borderRadius: "15px", padding: "25px",
                width: "400px", maxWidth: "95vw", fontFamily: "'Poppins',sans-serif", color: "#fff",
                display: "flex", flexDirection: "column", overflow: "hidden"
            });

            let rowsHTML = "";
            for (const r of results) {
                const pts = r.qualifPts ?? 0;
                let posColor = "#0077ff";
                if (r.displayPos === 1) posColor = "#FFD700";
                else if (r.displayPos === 2) posColor = "#C0C0C0";
                else if (r.displayPos === 3) posColor = "#CD7F32";

                rowsHTML += `
      <tr style="border-bottom:1px solid #333;">
        <td style="padding:10px;text-align:center;font-weight:800;color:${posColor};font-size:16px;">${r.displayPos}</td>
        <td style="padding:10px;font-weight:500;">${r.name}</td>
        <td style="padding:10px;text-align:right;font-family:'Courier New',monospace;color:#ccc;">${r.timeStr || "-"}</td>
        <td style="padding:10px;text-align:center;font-weight:bold;color:#00ffea;">+${pts}</td>
      </tr>`;
            }

            modalContent.innerHTML = `
    <div style="text-align:center;margin-bottom:15px;">
      <h2 style="margin:0;font-weight:800;letter-spacing:1px;font-size:22px;text-transform:uppercase;
        background:-webkit-linear-gradient(#fff,#999);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">
        RÉSULTATS QUALIF
      </h2>
      <p style="margin:5px 0 0;font-size:12px;color:#666;text-transform:uppercase;letter-spacing:2px;">Série validée</p>
    </div>

    <div style="overflow-y:auto;max-height:60vh;border-radius:8px;background:#111;border:1px solid #333;">
      <table style="width:100%;border-collapse:collapse;font-size:14px;">
        <thead>
          <tr style="background:#222;color:#888;font-size:11px;text-transform:uppercase;">
            <th style="padding:10px;">Pos</th>
            <th style="padding:10px;text-align:left;">Pilote</th>
            <th style="padding:10px;text-align:right;">Temps</th>
            <th style="padding:10px;">Pts</th>
          </tr>
        </thead>
        <tbody>${rowsHTML}</tbody>
      </table>
    </div>

    <div style="margin-top:20px;text-align:center;">
      <button id="closeRecapBtn" style="
        padding:10px 30px;border:none;border-radius:8px;
        background:linear-gradient(135deg,#0077ff,#0055cc);color:#fff;
        font-weight:bold;cursor:pointer;font-family:'Poppins',sans-serif;
        box-shadow:0 4px 15px rgba(0,119,255,0.4);transition:transform 0.2s;">
        FERMER
      </button>
    </div>
  `;

            wrapper.appendChild(modalContent);
            modal.appendChild(wrapper);
            document.body.appendChild(modal);

            requestAnimationFrame(() => {
                modal.style.opacity = "1";
                wrapper.style.transform = "scale(1)";
            });

            const closeBtn = modalContent.querySelector("#closeRecapBtn");
            const closeModal = () => {
                modal.style.opacity = "0";
                wrapper.style.transform = "scale(0.9)";
                setTimeout(() => modal.remove(), 300);
            };

            closeBtn.addEventListener("click", closeModal);
            modal.addEventListener("click", e => { if (e.target === modal) closeModal(); });
        }


        /* ---------- modal générique ---------- */
        function showModalForTime({ carName, onConfirm }) {
            document.querySelectorAll(".modal-overlay").forEach(m => m.remove());

            const modal = document.createElement("div");
            modal.className = "modal-overlay";
            Object.assign(modal.style, {
                position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.8)',
                display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 9999,
                backdropFilter: 'blur(5px)', opacity: '0', transition: 'opacity 0.2s ease'
            });

            const wrapper = document.createElement("div");
            Object.assign(wrapper.style, {
                position: 'relative', borderRadius: '18px', padding: '3px',
                background: 'linear-gradient(90deg, #ff003c, #0077ff, #ff003c)', backgroundSize: '300% 300%',
                boxShadow: '0 0 20px rgba(255,0,60,0.4), 0 0 30px rgba(0,120,255,0.3)',
                animation: 'ledPulse 3.5s ease-in-out infinite, ledGradient 6s linear infinite',
                transform: 'scale(0.9)', transition: 'transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275)'
            });

            const modalContent = document.createElement("div");
            Object.assign(modalContent.style, {
                background: '#1a1a1a', borderRadius: '15px', padding: '25px 30px',
                minWidth: '300px', fontFamily: "'Poppins', sans-serif", color: '#fff',
                textAlign: 'center', display: 'flex', flexDirection: 'column', gap: '10px'
            });

            modalContent.innerHTML = `
        <h2 style="margin: 0 0 10px; font-weight: 800; letter-spacing: 1px; font-size: 24px; text-transform: uppercase; background: -webkit-linear-gradient(#fff, #bbb); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
            ${carName}
        </h2>
        <div class="input-wrapper">
            <input type="text" id="timeInput" placeholder="00.000" autocomplete="off" />
        </div>
        <div id="msgZone" style="min-height: 18px; font-size: 12px; font-weight: 500; margin-top:5px;"></div>
    `;

            wrapper.appendChild(modalContent);
            modal.appendChild(wrapper);
            document.body.appendChild(modal);

            const timeInput = modalContent.querySelector("#timeInput");
            const msgZone = modalContent.querySelector("#msgZone");

            // Styles input
            Object.assign(timeInput.style, {
                width: '160px', padding: '8px', borderRadius: '8px', border: '2px solid #333',
                background: '#111', color: '#fff', caretColor: '#fff', fontFamily: "'Courier New', monospace",
                fontSize: '22px', fontWeight: 'bold', textAlign: 'center', outline: 'none',
                transition: 'all 0.3s ease', letterSpacing: '2px'
            });
            timeInput.addEventListener('focus', () => { timeInput.style.borderColor = '#0077ff'; timeInput.style.background = '#0a0a0a'; });
            timeInput.addEventListener('blur', () => { timeInput.style.borderColor = '#333'; timeInput.style.background = '#111'; });

            requestAnimationFrame(() => { modal.style.opacity = '1'; wrapper.style.transform = 'scale(1)'; });

            timeInput.focus();

            const closeModal = () => {
                modal.style.opacity = '0'; wrapper.style.transform = 'scale(0.9)';
                setTimeout(() => { modal.remove(); }, 200);
            };

            const handleSubmit = () => {
                const rawTime = timeInput.value.trim();

                if (rawTime === "") {
                    msgZone.textContent = "Temps vide : Annulé"; msgZone.style.color = "#aaa";
                    setTimeout(() => { closeModal(); if (typeof onConfirm === "function") onConfirm(null); }, 800);
                    return;
                }
                if (typeof normalizeTime !== 'function') {
                    closeModal(); if (typeof onConfirm === "function") onConfirm(rawTime.replace(',', '.')); return;
                }
                if (!(/^\d{1,2}[.,]\d{3}$/.test(rawTime) || /^dnf$/i.test(rawTime))) {
                    msgZone.textContent = "Format invalide (ex: 12.345)"; msgZone.style.color = "#ff4444";
                    wrapper.style.animation = "none"; wrapper.offsetHeight;
                    wrapper.style.animation = "shake 0.4s ease, ledPulse 3.5s infinite";
                    return;
                }
                const time = normalizeTime(rawTime);
                closeModal();
                if (typeof onConfirm === "function") onConfirm(time);
            };

            timeInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") { e.preventDefault(); handleSubmit(); }
                if (e.key === "Escape") { closeModal(); if (typeof onConfirm === "function") onConfirm(null); }
            });
            modal.addEventListener("click", e => {
                if (e.target === modal) { closeModal(); if (typeof onConfirm === "function") onConfirm(null); }
            });

            const style = document.createElement("style");
            if (!document.getElementById("modal-styles")) {
                style.id = "modal-styles";
                style.textContent = `
            @keyframes ledGradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
            @keyframes ledPulse { 0%, 100% { box-shadow: 0 0 20px rgba(255,0,60,0.4), 0 0 30px rgba(0,120,255,0.3); } 50% { box-shadow: 0 0 35px rgba(255,0,60,0.6), 0 0 50px rgba(0,120,255,0.5); } }
            @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        `;
                document.head.appendChild(style);
            }
        }


        /* ---------- flow qualification (AVEC GESTION DE PHASE) ---------- */
        startCalifBtn.addEventListener("click", () => {
            qualifState.inProgress = true;
            qualifState.serie = !serieA.classList.contains("hidden") ? "A" : "B";
            saveQualifState();

            const serieVisible = !serieA.classList.contains("hidden") ? "A" : "B";

            // 1. VERIFICATION DE LA PHASE (QUALIF vs RACE)
            // On lit la phase actuelle ("QUALIF" ou "RACE"). Par défaut, c'est "QUALIF".
            const currentPhase = localStorage.getItem(PHASE_KEY_PREFIX + serieVisible) || "QUALIF";

            if (currentPhase === "RACE") {
                showFastwayAlert(`La qualification est terminée pour la série ${serieVisible}.<br>Vous devez terminer la <b>COURSE</b> avant de relancer une qualif.`);
                return;
            }

            // 2. RESET AUTOMATIQUE (Si on est en phase QUALIF mais que l'ancienne est marquée "finished")
            if (serieVisible === "A" && finishedA && currentPhase === "QUALIF") {
                // C'est une NOUVELLE qualif après une course : on reset le flag
                finishedA = false;
                localStorage.setItem("finishedA", "false");
                // remainingCarsA sera vidé/re rempli par la logique ci-dessous
            }
            if (serieVisible === "B" && finishedB && currentPhase === "QUALIF") {
                finishedB = false;
                localStorage.setItem("finishedB", "false");
            }

            const serieElement = serieVisible === "A" ? serieA : serieB;
            // On ne prend que ceux qui n'ont PAS la classe 'eliminated-visual'
            const carNames = Array.from(serieElement.querySelectorAll(".column-row"))
                .filter(r => !r.classList.contains("eliminated-visual"))
                .map(r => r.children[2]?.textContent.trim())
                .filter(n => n);

            // Initialisation de la liste si vide (Ceci gère le reset des voitures)
            if (serieVisible === "A" && remainingCarsA.length === 0) remainingCarsA = shuffle(carNames.slice());
            if (serieVisible === "B" && remainingCarsB.length === 0) remainingCarsB = shuffle(carNames.slice());

            const remaining = serieVisible === "A" ? remainingCarsA : remainingCarsB;

            // Si plus de voitures, on termine
            if (remaining.length === 0) {
                assignQualifPointsForSeries(serieElement);

                // 3. PASSAGE EN PHASE COURSE
                // On verrouille la qualif pour cette série
                localStorage.setItem(PHASE_KEY_PREFIX + serieVisible, "RACE");

                if (serieVisible === "A") {
                    finishedA = true;
                    if (typeof endQualif === 'function') endQualif("A");
                } else {
                    finishedB = true;
                    if (typeof endQualif === 'function') endQualif("B");
                }
                return;
            }

            const currentCar = remaining[0];

            // Appel du Modal
            showModalForTime({
                carName: currentCar,
                onConfirm: (time) => {
                    if (time === null) {
                        return;
                    }

                    enregistrerLastTime(currentCar, time);
                    majBestTime(currentCar, time);

                    if (serieVisible === "A") {
                        remainingCarsA = remainingCarsA.slice(1);
                        localStorage.setItem("remainingCarsA", JSON.stringify(remainingCarsA));
                    } else {
                        remainingCarsB = remainingCarsB.slice(1);
                        localStorage.setItem("remainingCarsB", JSON.stringify(remainingCarsB));
                    }

                    saveAllData();
                    localStorage.setItem("finishedA", finishedA);
                    localStorage.setItem("finishedB", finishedB);

                    // Vérifier s'il reste des voitures
                    const newRemaining = (serieVisible === "A") ? remainingCarsA : remainingCarsB;
                    if (newRemaining.length === 0) {
                        assignQualifPointsForSeries(serieElement);

                        // --- VERROUILLAGE FIN DE QUALIF ---
                        localStorage.setItem(PHASE_KEY_PREFIX + serieVisible, "RACE");

                        if (serieVisible === "A") {
                            finishedA = true; localStorage.setItem("finishedA", "true");
                        } else {
                            finishedB = true; localStorage.setItem("finishedB", "true");
                        }
                        updateMainTable();
                        return;
                    }

                    setTimeout(() => startCalifBtn.click(), 250);
                },
                onSkip: () => { }
            });
        });

        /* ---------- helper modal simple ---------- */
        function showModalForSimpleMessage(message) {
            document.querySelectorAll(".modal-overlay").forEach(m => m.remove());

            const modal = document.createElement("div");
            modal.className = "modal-overlay";
            Object.assign(modal.style, {
                position: "fixed", inset: 0, background: "rgba(0,0,0,0.5)",
                display: "flex", alignItems: "center", justifyContent: "center", zIndex: 9999
            });

            const modalContent = document.createElement("div");
            Object.assign(modalContent.style, {
                background: "#fff", padding: "14px", borderRadius: "8px", textAlign: "center"
            });
            modalContent.innerHTML = `<h2>${message}</h2><p>Cliquez pour fermer.</p>`;
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            modal.addEventListener("click", () => modal.remove());
        }

        /* ---------- fonctions utilitaires pour temps ---------- */
        function enregistrerLastTime(carName, rawTime) {
            if (rawTime === null) return;
            const time = normalizeTime(rawTime);
            const allRows = Array.from(document.querySelectorAll(".column-row"));
            for (const row of allRows) {
                const nameCell = row.children[2];
                if (nameCell && nameCell.textContent.trim() === carName) {
                    let lastTimeCell = row.querySelector(".last-time");
                    if (!lastTimeCell) {
                        lastTimeCell = document.createElement("div");
                        lastTimeCell.className = "last-time";
                        lastTimeCell.style.display = "none";
                        row.appendChild(lastTimeCell);
                    }
                    lastTimeCell.textContent = time || "DNF";
                    carTimes[carName] = time || "DNF";
                    break;
                }
            }
        }

        function majBestTime(carName, time) {
            if (time === null) return;
            const allRows = Array.from(document.querySelectorAll(".column-row"));
            for (const row of allRows) {
                const nameCell = row.children[2];
                if (nameCell && nameCell.textContent.trim() === carName) {
                    const bestTimeCell = row.children[6];
                    const currentBest = (bestTimeCell && bestTimeCell.textContent) ? bestTimeCell.textContent.trim() : "";
                    const currentBestNum = (currentBest === "" || /^dnf$/i.test(currentBest)) ? Infinity : parseFloat(currentBest.replace(",", "."));
                    const newTimeNum = (/^dnf$/i.test(time)) ? Infinity : parseFloat(time.replace(",", "."));
                    if (newTimeNum < currentBestNum || currentBest === "") {
                        bestTimeCell.textContent = time || "DNF";
                    }
                    break;
                }
            }
        }

        /* ---------- UNDO (Qualif) ---------- */
        undoQualifBtn && undoQualifBtn.addEventListener("click", () => {
            if (qualifhistory.length === 0) {
                showFastwayAlert("Aucune qualification à annuler.", "HISTORIQUE VIDE");
                return;
            }

            // Pour le confirm, on peut utiliser le natif car il demande un choix OUI/NON, 
            // ou alors on doit créer un showFastwayConfirm (plus complexe).
            // Pour l'instant, gardons le confirm natif pour la sécurité, ou dis-moi si tu veux aussi styliser le Oui/Non.
            if (!confirm("Es-tu sûr de vouloir annuler la dernière qualification ?")) return;

            const last = qualifhistory.pop();
            // ... (le reste du code undo reste identique) ...
            delete carTimes[last.car];
            if (!serieA.classList.contains("hidden")) { remainingCarsA.push(last.car); finishedA = false; }
            else { remainingCarsB.push(last.car); finishedB = false; }
            const rows = Array.from(document.querySelectorAll(".column-row"));
            for (const row of rows) {
                const nameCell = row.children[2];
                if (nameCell && nameCell.textContent.trim() === last.car) {
                    if (row.children[6]) row.children[6].textContent = "";
                    break;
                }
            }
            saveAllData();
            restoreTotalPoints();
            updateMainTable();
        });












        /* ---------- VARIABLES ---------- */
        let qualifA_done = false;
        let qualifB_done = false;
        let raceA_done = false;
        let raceB_done = false;
        let raceCount = 0;

        // Index des colonnes dans le tableau principal
        const COL_WIN = 4;
        const COL_CH_WIN = 5;
        const COL_BEST_TIME = 6;
        const COL_WIN_PERCENT = 7;
        const COL_TOTAL = 8;
        const COL_LAST_TIME = 9; // Ajouté pour éviter l'erreur

        /* États séparés par série */
        let raceStates = {
            A: {
                racePaused: false,
                raceRound: 1,
                raceQueue: [],
                raceWinners: [],
                currentDuels: [],
                raceFinished: false,
                bestTimes: {},
                carStats: {} // <-- ajouté ici
            },
            B: {
                racePaused: false,
                raceRound: 1,
                raceQueue: [],
                raceWinners: [],
                currentDuels: [],
                raceFinished: false,
                bestTimes: {},
                carStats: {} // <-- ajouté ici
            }
        };

        let raceSerieVisible = "A"; // série visible actuelle
        const RACE_STATE_KEY = "fastway_race_state_v2"; // clé localStorage

        /* ---------- UTILITAIRES ---------- */
        /* ---------- CONFIGURATION PLAYOFFS ---------- */
        const MAX_RACES = 1; // Saison régulière (modifiable pour test)

        // Structure des rounds
        const PLAYOFF_STRUCTURE = [
            { name: "ROUND 1", races: 3, targetCount: 10 }, // On commence à 14, on finit à 10
            { name: "ROUND 2", races: 3, targetCount: 6 },  // On commence à 10, on finit à 6
            { name: "ROUND 3", races: 2, targetCount: 2 },  // On commence à 6, on finit à 2
            { name: "DIVISION FINAL", races: 5, targetCount: 1 } // Best of 5 (Duel)
        ];

        // État global des playoffs
        let playoffState = {
            active: false,
            currentRoundIndex: 0, // 0 = Round 1, 1 = Round 2...
            currentRaceInRound: 0,
            isFinal: false // Pour le FASTWAY FINAL (A vs B)
        };

        function handlePlayoffProgression() {
            // Si on est en finale globale (A vs B)
            if (playoffState.isFinal) {
                // Logique Best of 7 ici (à implémenter si besoin, c'est un cas spécial hors série A/B classique)
                showFastwayAlert("FASTWAY FINAL UPDATE: Logique Best of 7 en cours...", "FINAL");
                return;
            }

            const currentStructure = PLAYOFF_STRUCTURE[playoffState.currentRoundIndex];
            playoffState.currentRaceInRound++;

            // Vérifier si le round est fini
            if (playoffState.currentRaceInRound >= currentStructure.races) {
                // --- FIN DU ROUND : ÉLIMINATION ---

                // Fonction pour couper les voitures
                const cutSeries = (serieKey, keepCount) => {
                    const qualifiedList = (serieKey === 'A') ? playoffData.A.qualified : playoffData.B.qualified;
                    const container = (serieKey === 'A') ? document.getElementById('serie-a') : document.getElementById('serie-b');
                    const rows = Array.from(container.querySelectorAll('.column-row'));

                    // On ne prend que ceux qui sont encore en course
                    let contenders = rows.filter(r => qualifiedList.includes(r.children[2].textContent.trim()));

                    // Tri par Total Points (Wins*10 + Pts)
                    contenders.sort((a, b) => {
                        const getPts = r => (parseInt(r.children[4].textContent) * 10) + parseInt(r.children[COL_POINT_CALIF].textContent);
                        return getPts(b) - getPts(a);
                    });

                    // On garde les 'keepCount' premiers
                    const survivors = contenders.slice(0, keepCount).map(r => r.children[2].textContent.trim());
                    const eliminated = contenders.slice(keepCount).map(r => r.children[2].textContent.trim());

                    // Mise à jour visuelle (Griser les éliminés)
                    rows.forEach(r => {
                        const name = r.children[2].textContent.trim();
                        if (eliminated.includes(name)) {
                            r.classList.add("eliminated-visual");
                            r.classList.remove("playoff-qualified");
                        }
                    });

                    return survivors;
                };

                playoffData.A.qualified = cutSeries('A', currentStructure.targetCount);
                playoffData.B.qualified = cutSeries('B', currentStructure.targetCount);

                // Passer au round suivant
                playoffState.currentRoundIndex++;
                playoffState.currentRaceInRound = 0;

                // Vérifier si c'était le dernier round de division (Finale Division finie ?)
                if (playoffState.currentRoundIndex >= PLAYOFF_STRUCTURE.length) {
                    // C'est fini pour les divisions -> Place au FASTWAY FINAL
                    setupFastwayFinal();
                } else {
                    const nextRoundName = PLAYOFF_STRUCTURE[playoffState.currentRoundIndex].name;
                    showFastwayAlert(
                        `Round terminé ! Des voitures ont été éliminées.<br>Début du <b>${nextRoundName}</b>.<br>Nombre de courses : ${PLAYOFF_STRUCTURE[playoffState.currentRoundIndex].races}`,
                        "PLAYOFF UPDATE"
                    );
                    resetForNextRace();
                }

            } else {
                // --- LE ROUND CONTINUE ---
                showFastwayAlert(
                    `${currentStructure.name}<br>Course ${playoffState.currentRaceInRound} / ${currentStructure.races} terminée.`,
                    "PLAYOFF PROGRESS"
                );
                resetForNextRace();
            }
        }

        function setupFastwayFinal() {
            playoffState.isFinal = true;
            const winnerA = playoffData.A.qualified[0];
            const winnerB = playoffData.B.qualified[0];

            showFastwayAlert(
                `<div style="text-align:center">
            <h1 style="color:#FFD700; font-size:30px;">DIVISION CHAMPIONS</h1>
            <p>Série A : <b>${winnerA}</b></p>
            <p>Série B : <b>${winnerB}</b></p>
            <hr>
            <p>Le <b>FASTWAY FINAL</b> commence ! (Best of 7)</p>
        </div>`,
                "THE FINAL BATTLE"
            );

            // Note : Ici il faudrait une logique spéciale pour un duel inter-séries A vs B.
            // Pour l'instant, le code s'arrête là proprement.
        }

        /* ---------- GESTION DELTA POSITIONS ---------- */
        function saveRankBenchmark(serie) {
            // 1. On récupère toutes les lignes TRIÉES de la série
            const container = (serie === 'A') ? serieA : serieB;
            const rows = Array.from(container.querySelectorAll(".column-row"));

            // 2. On crée une map : "NomVoiture" => Rang (Index + 1)
            const rankMap = {};
            rows.forEach((row, index) => {
                const name = row.children[2]?.textContent.trim();
                if (name) {
                    rankMap[name] = index + 1;
                }
            });

            // 3. On sauvegarde dans localStorage
            localStorage.setItem(`fastway_benchmark_${serie}`, JSON.stringify(rankMap));
        }

        function updateRaceCounterUI() {

            // Récupération sécurisée du compteur (inchangée)
            let currentCount = 0;
            if (typeof raceCount !== 'undefined') {
                currentCount = raceCount;
            } else {
                try {
                    const raw = localStorage.getItem('RACE_STATE_KEY_DEMO'); // Utilisez votre vraie clé ici
                    const saved = JSON.parse(raw || '{}');
                    currentCount = saved.raceCount || 0;
                } catch (e) { }
            }

            let counterEl = document.getElementById('race-counter');
            const buttonsContainer = document.querySelector('.race-buttons');

            // 1. Création et Positionnement (inchangé)
            if (!counterEl && buttonsContainer) {
                counterEl = document.createElement('div');
                counterEl.id = 'race-counter';

                buttonsContainer.style.position = 'relative';

                Object.assign(counterEl.style, {
                    position: 'absolute',
                    top: '-15px',
                    right: '-213px',
                    width: 'auto',
                    whiteSpace: 'nowrap',
                    fontSize: '15px',
                    fontFamily: "'Poppins', sans-serif",
                    fontWeight: '800',
                    letterSpacing: '1.2px',
                    pointerEvents: 'none',
                    textTransform: 'uppercase',
                    textAlign: 'right'
                });

                buttonsContainer.appendChild(counterEl);
            }

            // --- LOGIQUE DE MISE À JOUR DU COMPTEUR ---
            let currentRace = currentCount; // Par défaut : Saison régulière
            let maxRaces = MAX_RACES;      // Par défaut : MAX_RACES
            let raceLabelText = 'RACES';   // Par défaut : RACES

            if (playoffState && playoffState.active) {
                // En mode Playoff
                const currentStructure = PLAYOFF_STRUCTURE[playoffState.currentRoundIndex];

                // Le compteur affiche la course qui va être jouée (courses terminées + 1)
                // Attention : Si le round est fini, on garde le max pour le round complété
                currentRace = Math.min(playoffState.currentRaceInRound + 1, currentStructure.races);

                // Le maximum de courses est le total pour ce round
                maxRaces = currentStructure.races;

                // Le libellé affiche le nom du Round (ex: ROUND 1)
                raceLabelText = currentStructure.name;

                // Gestion de la finale (optionnel, si la variable est bien définie)
                if (playoffState.isFinal) {
                    maxRaces = 7; // Best of 7
                    raceLabelText = "FASTWAY FINAL";
                }
            }


            // 2. Mise à jour du texte
            if (counterEl) {
                // J'utilise le format: RACES 1 / 14 (ou ROUND 1 1 / 3)
                counterEl.innerHTML = `
            <span style="color:#000; font-size:15px; margin-right:5px;">${raceLabelText}</span>
            <span style="color:#000; font-size:16px;">${currentRace}</span>
            <span style="color:#000; margin:0 1px; font-size:16px;">/</span> 
            <span style="color:#000; font-size:16px;">${maxRaces}</span>
        `;
            }
        }

        function applySavedBestTimes() {
            ['A', 'B'].forEach(seriesKey => {
                const state = raceStates[seriesKey];
                if (!state || !state.bestTimes) return;

                Object.entries(state.bestTimes).forEach(([name, time]) => {
                    const row = findRowByName(name);
                    if (!row) return;

                    // Vérifier à quelle série appartient la row
                    const rowSeries = serieB.contains(row) ? 'B' : 'A';
                    if (rowSeries !== seriesKey) return; // skip si mauvais tableau

                    const bestEl = row.querySelector(".best-time");
                    if (bestEl) bestEl.textContent = time;
                    else if (typeof COL_BEST_TIME !== "undefined" && row.children[COL_BEST_TIME]) {
                        row.children[COL_BEST_TIME].textContent = time;
                    }
                });
            });
        }

        function endQualif(serie) {
            if (serie === 'A') {
                finishedA = true;
                qualifA_done = true;
            }
            if (serie === 'B') {
                finishedB = true;
                qualifB_done = true;
            }
            saveRaceState();
        }

        function canStartRace() {
            if (!qualifA_done || !qualifB_done) {
                alert("Les deux qualifications (A et B) doivent être terminées avant de commencer la course !");
                return false;
            }
            return true;
        }

        function endRace(serie) {
            // 1. Marquer la série comme finie
            if (serie === 'A') { raceA_done = true; finishedA = true; }
            if (serie === 'B') { raceB_done = true; finishedB = true; }

            const state = getCurrentState();
            if (state) state.raceFinished = true;
            saveRaceState();

            // 2. Attendre que A et B soient finis
            if (raceA_done && raceB_done) {

                // --- CAS 1 : SAISON RÉGULIÈRE ---
                if (!playoffState.active) {
                    raceCount++;
                    if (raceCount >= MAX_RACES) {
                        setTimeout(() => {
                            calculatePlayoffFieldAndStartRound1();
                        }, 2000);
                    } else {
                        // Reset pour prochaine course régulière
                        resetForNextRace();
                        showFastwayAlert(`Race ${raceCount}/${MAX_RACES} terminée.`, "NEXT RACE");
                    }
                }
                // --- CAS 2 : PLAYOFFS ---
                else {
                    handlePlayoffProgression();
                }
            }

            saveRaceState();
            if (typeof updateRaceUI === 'function') updateRaceUI();
        }

        // Fonction utilitaire pour reset les flags
        function resetForNextRace() {
            raceA_done = false; raceB_done = false;
            qualifA_done = false; qualifB_done = false;
            finishedA = false; finishedB = false;

            if (raceStates.A) { raceStates.A.raceFinished = false; raceStates.A.raceQueue = []; raceStates.A.raceWinners = []; raceStates.A.currentDuels = []; }
            if (raceStates.B) { raceStates.B.raceFinished = false; raceStates.B.raceQueue = []; raceStates.B.raceWinners = []; raceStates.B.currentDuels = []; }

            localStorage.setItem("fastway_phase_A", "QUALIF");
            localStorage.setItem("fastway_phase_B", "QUALIF");
            localStorage.setItem("finishedA", "false");
            localStorage.setItem("finishedB", "false");
        }

        function getCurrentState() {
            return raceStates[raceSerieVisible];
        }

        let gamePhase = "REGULAR_SEASON"; // "REGULAR_SEASON", "TIE_BREAKER", "PLAYOFF_R1", etc.
        let playoffData = {
            A: { qualified: [], eliminationCount: 0 },
            B: { qualified: [], eliminationCount: 0 }
        };


        /* ---------- LOGIQUE DE SÉLECTION PLAYOFFS ---------- */
        function getQualifiedPlayoffCars(seriesKey) {
            const rows = (seriesKey === 'A') ?
                Array.from(document.querySelectorAll('#serie-a .column-row')) :
                Array.from(document.querySelectorAll('#serie-b .column-row'));

            // 1. Extraire les données
            let cars = rows.map(row => {
                const name = row.children[2].textContent.trim();
                const pts = parseInt(row.children[COL_POINT_CALIF]?.textContent || "0", 10) || 0;
                const wins = parseInt(row.children[4]?.textContent || "0", 10) || 0;
                const chWins = parseInt(row.children[5]?.textContent || "0", 10) || 0; // Victoires Championnat
                const total = (wins * 10) + pts; // Ton calcul de total habituel
                return { name, chWins, total, originalRow: row };
            });

            // 2. Le Tri : D'abord CH Wins, ensuite Total Points
            cars.sort((a, b) => {
                if (b.chWins !== a.chWins) return b.chWins - a.chWins; // Plus de victoires d'abord
                return b.total - a.total; // Sinon, plus de points
            });

            // 3. Sélection des 14 premiers
            const CUTOFF = 14;

            // Vérification de l'égalité à la frontière (entre le 14ème et le 15ème)
            // Index 13 = 14ème voiture, Index 14 = 15ème voiture
            if (cars.length > CUTOFF) {
                const car14 = cars[CUTOFF - 1]; // Le dernier qualifié potentiel
                const car15 = cars[CUTOFF];     // Le premier éliminé potentiel

                // Si le 14e et le 15e ont le MÊME score (CH Wins ET Total Points)
                if (car14.chWins === car15.chWins && car14.total === car15.total) {
                    return {
                        status: "TIE",
                        contenders: [car14.name, car15.name],
                        qualifiedList: null
                    };
                }
            }

            // Pas d'égalité, on prend les 14 premiers
            const qualifiedNames = cars.slice(0, CUTOFF).map(c => c.name);
            return {
                status: "OK",
                contenders: [],
                qualifiedList: qualifiedNames
            };
        }

        function updateTableVisibilityForPlayoffs(seriesKey, qualifiedNames) {
            const container = (seriesKey === 'A') ?
                document.getElementById('serie-a') :
                document.getElementById('serie-b');

            const rows = Array.from(container.querySelectorAll('.column-row'));

            rows.forEach(row => {
                const name = row.children[2].textContent.trim();
                if (qualifiedNames.includes(name)) {
                    row.style.display = "flex"; // Afficher
                    row.classList.add("playoff-qualified"); // Pour le style futur (bordure or ?)
                } else {
                    row.style.display = "none"; // Masquer les éliminés
                }
            });

            // Optionnel : Recalculer les positions visuelles de 1 à 14
            let rank = 1;
            rows.forEach(row => {
                if (row.style.display !== "none") {
                    if (row.children[0]) {
                        // On garde ton système de delta, on change juste le chiffre
                        const rankSpan = row.querySelector('.rank-number');
                        if (rankSpan) rankSpan.textContent = rank;
                        else row.children[0].textContent = rank;
                    }
                    rank++;
                }
            });
        }

        function calculatePlayoffFieldAndStartRound1() {
            console.log("DÉBUT CALCUL PLAYOFFS (Version Officielle)...");

            // Fonction de tri et sélection (interne)
            const processSeries = (serieKey) => {
                const container = (serieKey === 'A') ? document.getElementById('serie-a') : document.getElementById('serie-b');
                const rows = Array.from(container.querySelectorAll('.column-row'));

                // 1. Extraction des données
                let cars = rows.map(row => {
                    const name = row.children[2].textContent.trim();
                    const pts = parseInt(row.children[COL_POINT_CALIF]?.textContent || "0", 10) || 0;
                    const wins = parseInt(row.children[4]?.textContent || "0", 10) || 0;
                    const chWins = parseInt(row.children[5]?.textContent || "0", 10) || 0;
                    const total = (wins * 10) + pts;
                    return { name, chWins, total, row };
                });

                // 2. Tri : CH WIN d'abord, puis POINTS
                cars.sort((a, b) => {
                    if (b.chWins !== a.chWins) return b.chWins - a.chWins;
                    return b.total - a.total;
                });

                // 3. Gestion du CUT à 14
                const CUTOFF = 14;

                // Vérification égalité (Tie-Breaker simple pour l'instant)
                if (cars.length > CUTOFF) {
                    const car14 = cars[CUTOFF - 1];
                    const car15 = cars[CUTOFF];

                    // Si égalité stricte sur le cut
                    if (car14.chWins === car15.chWins && car14.total === car15.total) {
                        // NOTE : Pour respecter ton "tournoi", il faudrait ici une logique complexe.
                        // Pour l'instant, on avertit l'utilisateur.
                        showFastwayAlert(
                            `ÉGALITÉ CRITIQUE SÉRIE ${serieKey} !<br>Voitures: ${car14.name} vs ${car15.name}<br>Veuillez faire un duel manuel pour les départager avant de continuer.`,
                            "TIE BREAKER REQUIS"
                        );
                        return null; // On bloque
                    }
                }

                const qualifiedNames = cars.slice(0, CUTOFF).map(c => c.name);

                // 4. Application visuelle (GRIS PÂLE)
                cars.forEach(c => {
                    if (qualifiedNames.includes(c.name)) {
                        c.row.classList.remove("eliminated-visual");
                        c.row.classList.add("playoff-qualified");
                    } else {
                        c.row.classList.add("eliminated-visual"); // Gris au lieu de caché
                        c.row.classList.remove("playoff-qualified");
                    }
                });

                return qualifiedNames;
            };

            const qualifA = processSeries('A');
            if (!qualifA) return; // Bloqué par tie-break

            const qualifB = processSeries('B');
            if (!qualifB) return; // Bloqué par tie-break

            // Mise à jour des données globales
            playoffData.A.qualified = qualifA;
            playoffData.B.qualified = qualifB;

            gamePhase = "PLAYOFF_R1";
            playoffState.active = true;
            playoffState.currentRoundIndex = 0; // Round 1
            playoffState.currentRaceInRound = 0;

            resetForNextRace();
            saveRaceState();

            showFastwayAlert(
                "Season just ended! All regular races are complete.<br>Time to calculate the final standings and set the grid for next weekend's Playoffs start!",
                "SEASON ENDED"
            );
        }

        /* ---------- LOGIQUE SAUVEGARDE ---------- */
        function saveRaceState() {
            const state = {
                finishedA,
                finishedB,
                qualifA_done,
                qualifB_done, // <--- CRITIQUE: doit être là
                raceA_done,
                raceB_done,   // <--- CRITIQUE: doit être là
                raceCount,    // <--- CRITIQUE: doit être là
                raceStates,
                gamePhase,
                playoffData
            };
            localStorage.setItem(RACE_STATE_KEY, JSON.stringify(state));
        }

        function loadRaceState() {
            try {
                const raw = localStorage.getItem(RACE_STATE_KEY);
                if (!raw) return;
                const s = JSON.parse(raw);

                // 1. Chargement et Auto-Réparation des Qualifications (Logique précédente)
                finishedA = s.finishedA || false;
                finishedB = s.finishedB || false;

                // Si finishedX est true, qualifX_done doit l'être aussi (Auto-réparation Qualif)
                qualifA_done = s.qualifA_done || finishedA;
                qualifB_done = s.qualifB_done || finishedB;

                // 2. Chargement et Auto-Réparation des Courses (AJOUT DE SÉCURITÉ ICI)
                raceA_done = s.raceA_done || false;
                raceB_done = s.raceB_done || false;


                // CHARGEMENT DU COMPTEUR
                if (typeof s.raceCount !== 'undefined') {
                    raceCount = s.raceCount;
                } else {
                    raceCount = 0;
                }

                if (s.raceStates) raceStates = s.raceStates;

                // Réappliquer les stats sauvegardées sur le tableau (inchangé)
                ['A', 'B'].forEach(seriesKey => {
                    const state = raceStates[seriesKey];
                    if (!state || !state.carStats) return;

                    Object.entries(state.carStats).forEach(([name, stats]) => {
                        const row = findRowByName(name);
                        if (!row) return;

                        // ... (Chargement des stats du tableau inchangé) ...
                        if (stats.wins !== undefined) {
                            const winEl = row.querySelector('.win') || (typeof COL_WIN !== 'undefined' ? row.children[COL_WIN] : null);
                            if (winEl) winEl.textContent = stats.wins;
                        }

                        if (stats.losses !== undefined) {
                            const lossEl = row.querySelector('.loss');
                            if (lossEl) lossEl.textContent = stats.losses;
                        }

                        if (stats.champWins !== undefined) {
                            const champEl = row.querySelector('.ch-win');
                            if (champEl) {
                                champEl.textContent = stats.champWins;
                            } else if (typeof COL_CH_WIN !== "undefined" && row.children[COL_CH_WIN]) {
                                row.children[COL_CH_WIN].textContent = stats.champWins;
                            }
                        }

                        if (stats.bestTime !== undefined) {
                            const timeEl = row.querySelector('.best-time') || (typeof COL_BEST_TIME !== 'undefined' ? row.children[COL_BEST_TIME] : null);
                            if (timeEl) timeEl.textContent = stats.bestTime;
                        }
                    });
                });
            } catch (e) {
                console.warn("Impossible de charger l'état de la course:", e);
            }

            // Appel pour mettre à jour l'affichage du compteur après le chargement
            if (typeof updateRaceCounterUI === 'function') {
                updateRaceCounterUI();
            }
        }

        function getSerieRows() {
            return Array.from(
                raceSerieVisible === "A"
                    ? serieA.querySelectorAll(".column-row")
                    : serieB.querySelectorAll(".column-row")
            );
        }

        function getAllSerieRows() {
            return [...serieA.querySelectorAll('.column-row'), ...serieB.querySelectorAll('.column-row')];
        }

        function isQualifDone() {
            return raceSerieVisible === "A" ? qualifA_done : qualifB_done;
        }

        function findRowByName(name) {
            if (!name) return null;
            return getAllSerieRows().find(r => (r.children[2]?.textContent || '').trim() === name) || null;
        }

        /* Convertit "00.000" ou "dnf" en nombre (ms) */
        function safeTimeToNumber(t) {
            if (typeof timeToNumber === "function") return timeToNumber(t);
            if (!t) return Infinity;

            const s = ('' + t).trim().toLowerCase();
            if (s === 'dnf' || s === 'dnq' || s === '-') return Infinity;

            const parts = s.split(":").map(p => parseFloat(p.replace(",", ".")));
            if (parts.length === 1) return Math.round(parts[0] * 1000);
            if (parts.length === 2) return Math.round((parseFloat(parts[0]) * 60 + parseFloat(parts[1])) * 1000);
            return Infinity;
        }

        /* Récupère last times et fait tri : plus rapide d'abord */
        function getLastTimesAndSort() {
            const rows = getSerieRows();
            const cars = rows.map(row => {
                const name = (row.children[2]?.textContent || '').trim();
                let lastTime = row.querySelector(".last-time")?.textContent?.trim() || (row.children[COL_LAST_TIME]?.textContent?.trim() || 'dnf');
                let points = parseInt(row.children[COL_POINT_CALIF]?.textContent || "0", 10) || 0;
                return { row, name, lastTime, points };
            }).filter(c => c.name);

            cars.sort((a, b) => {
                const tA = safeTimeToNumber(a.lastTime);
                const tB = safeTimeToNumber(b.lastTime);
                if (tA !== tB) return tA - tB;
                if (a.points !== b.points) return b.points - a.points;
                return Math.random() > 0.5 ? 1 : -1;
            });

            return cars;
        }

        /* Met à jour une ligne quand on modifie des temps/wins */
        function updateRowTimeAndMaybeBest(row, manualTimeStr) {
            if (!row) return;
            const name = row.children[2]?.textContent.trim();

            // Déterminer série
            const seriesKey = serieB.contains(row) ? 'B' : 'A';
            const state = raceStates[seriesKey];

            const lastEl = row.querySelector(".last-time");
            const bestEl = row.querySelector(".best-time");
            const oldBest = bestEl ? bestEl.textContent.trim() : (row.children[COL_BEST_TIME]?.textContent?.trim() || "");

            if (lastEl) lastEl.textContent = manualTimeStr;
            else if (typeof COL_LAST_TIME !== "undefined" && row.children[COL_LAST_TIME]) {
                row.children[COL_LAST_TIME].textContent = manualTimeStr;
            }

            const oldBestNum = safeTimeToNumber(oldBest);
            const newNum = safeTimeToNumber(manualTimeStr);
            if (newNum < oldBestNum) {
                if (bestEl) bestEl.textContent = manualTimeStr;
                else if (typeof COL_BEST_TIME !== "undefined" && row.children[COL_BEST_TIME]) {
                    row.children[COL_BEST_TIME].textContent = manualTimeStr;
                }

                // Sauvegarde dans le bon état
                state.bestTimes[name] = manualTimeStr;
                saveRaceState();
            }
        }

        /* ---------- WIN COLUMNS ---------- */
        function incrementWinColumns(row, delta = 1) {
            if (!row) return;
            // Mettre à jour DOM si présent
            if (typeof COL_WIN !== 'undefined') {
                const el = row.children[COL_WIN];
                const cur = parseInt(el.textContent || '0', 10) || 0;
                el.textContent = cur + delta;
            } else {
                const winEl = row.querySelector('.win');
                if (winEl) {
                    const cur = parseInt(winEl.textContent || '0', 10) || 0;
                    winEl.textContent = cur + delta;
                }
            }

            // Mettre à jour l'état sauvegardé (source de vérité)
            const name = (row.children[2]?.textContent || '').trim();
            if (!name) return;
            const state = getCurrentState();
            if (!state.carStats) state.carStats = {};
            if (!state.carStats[name]) state.carStats[name] = { wins: 0, losses: 0 };

            state.carStats[name].wins = parseInt(state.carStats[name].wins || 0, 10) + delta;
            saveRaceState(); // <-- La victoire est sauvegardée ici.


            if (typeof updateWinPercentage === 'function') updateWinPercentage(row);
            if (typeof updateMainTable === 'function') updateMainTable();
        }

        function updateWinPercentage(row, explicitState = null) {
            if (!row) return;
            // Détermine l'état (state) à utiliser : param explicite > état courant de la série visible
            let state = explicitState || getCurrentState();

            // Si on a reçu une ligne provenant de la table A ou B, on peut essayer de sélectionner l'état approprié.
            // (Si explicitState fourni, on l'utilise directement.)
            if (!explicitState) {
                // Ne rien changer : getCurrentState() garde le comportement existant pour la majorité des appels.
            }

            if (!state.carStats) state.carStats = {};

            const name = (row.children[2]?.textContent || '').trim();
            if (!name) return;

            if (!state.carStats[name]) state.carStats[name] = { wins: 0, losses: 0 };

            // Forcer en nombres
            const wins = parseInt(state.carStats[name].wins || 0, 10) || 0;
            const losses = parseInt(state.carStats[name].losses || 0, 10) || 0;
            const total = wins + losses;

            let percent;
            if (total === 0) {
                percent = "--";
            } else {
                let value = (wins / total) * 100;
                value = Math.round(value * 10) / 10;
                percent = value % 1 === 0 ? value.toFixed(0) + "%" : value.toFixed(1) + "%";
            }

            if (typeof COL_WIN_PERCENT !== "undefined" && row.children[COL_WIN_PERCENT]) {
                row.children[COL_WIN_PERCENT].textContent = percent;
            } else {
                const cell = row.querySelector(".win-percent");
                if (cell) cell.textContent = percent;
            }

            // On ne save pas l'état ici — l'appelant gère le save si besoin.
        }

        function incrementChampWinColumn(row) {
            if (!row) return;

            const name = (row.children[2]?.textContent || '').trim();
            if (!name) return;

            // Déterminer la série (A ou B)
            const seriesKey = serieB.contains(row) ? 'B' : 'A';
            const state = raceStates[seriesKey];

            if (!state.carStats) state.carStats = {};
            if (!state.carStats[name]) state.carStats[name] = { wins: 0, losses: 0, champWins: 0 };

            // Incrémentation du compteur en mémoire
            state.carStats[name].champWins = (state.carStats[name].champWins || 0) + 1;

            // Mettre à jour le DOM
            if (typeof COL_CH_WIN !== 'undefined') {
                const el = row.children[COL_CH_WIN];
                el.textContent = state.carStats[name].champWins;
            } else {
                const chEl = row.querySelector('.ch-win');
                if (chEl) chEl.textContent = state.carStats[name].champWins;
            }

            // Sauvegarde dans le localStorage
            saveRaceState();
        }

        /* ---------- Round / Free Pass Modal FASTWAY Version (CORRIGÉE) ---------- */
        function showRoundModal(title, message, freePassInfo = "", onClose) {
            // 1. Nettoyage
            document.querySelectorAll('.modal-overlay').forEach(m => m.remove());

            // 2. Overlay
            const modal = document.createElement('div');
            modal.className = "modal-overlay";
            Object.assign(modal.style, {
                position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)',
                display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 9999,
                backdropFilter: 'blur(10px)', opacity: '0', transition: 'opacity 0.3s ease'
            });

            // 3. Wrapper LED (Cadre animé)
            const wrapper = document.createElement('div');
            Object.assign(wrapper.style, {
                position: 'relative', borderRadius: '24px', padding: '3px',
                background: 'linear-gradient(90deg, #ff003c, #0077ff, #ff003c)', backgroundSize: '300% 300%',
                boxShadow: '0 0 40px rgba(255,0,60,0.3), 0 0 50px rgba(0,120,255,0.2)',
                animation: 'ledPulse 3.5s ease-in-out infinite, ledGradient 4s linear infinite',
                transform: 'scale(0.9)', transition: 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)'
            });

            // 4. Contenu
            const modalContent = document.createElement('div');
            Object.assign(modalContent.style, {
                background: '#111', borderRadius: '21px', padding: '30px 40px',
                width: '350px', maxWidth: '90vw',
                fontFamily: "'Poppins', sans-serif", color: '#fff', textAlign: 'center',
                position: 'relative'
            });

            // Correction du bug d'affichage : assure que freePassInfo est une chaîne vide si non défini ou une fonction.
            const displayFreePassInfo = (typeof freePassInfo === 'string' && freePassInfo) ? freePassInfo : '';

            modalContent.innerHTML = `
        <h2 class="round-title" style="margin-bottom: 20px;">${title}</h2>
        <p style="margin-bottom: 25px; font-size: 16px; color: #ccc;">${message}</p>
        
        ${displayFreePassInfo ?
                    `<div class="free-pass-info" style="margin-bottom: 30px; font-size: 14px; font-weight: 600; color: #ffea00; text-shadow: 0 0 8px rgba(255, 234, 0, 0.4);">
                ${displayFreePassInfo}
            </div>`
                    : ''
                }
        
        <div class="modal-buttons" style="margin-top: ${displayFreePassInfo ? '0' : '30px'};">
            <button id="roundNextBtn" class="next-btn">
                NEXT ROUND
            </button>
        </div>
    `;

            wrapper.appendChild(modalContent);
            modal.appendChild(wrapper);
            document.body.appendChild(modal);

            // --- STYLES CSS INJECTÉS (CORRIGÉ) ---
            // J'utilise un nouvel ID pour être sûr que le navigateur applique le style mis à jour.
            const styleId = "round-modal-styles-v3";
            if (!document.getElementById(styleId)) {
                const style = document.createElement('style');
                style.id = styleId;

                // ATTENTION : Le code CSS doit être dans style.textContent, pas juste après le commentaire.
                style.textContent = `
            /* Titre du Round */
            .round-title { 
                font-weight: 900; 
                letter-spacing: 2px; 
                font-size: 26px; 
                text-transform: uppercase; 
                color: #fff; 
                text-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            }

            /* Bouton Principal "Next" (Hover DOUX et Couleurs HARMONISÉES) */
           /* Bouton Principal "Next" — Version ULTRA SMOOTH */
.next-btn {
    padding: 14px 40px;
    background: linear-gradient(135deg, #ff3355, #cc0033);
    border: 2px solid #ff1e4d;
    border-radius: 12px;
    color: #fff;
    font-weight: 800;
    font-size: 17px;
    cursor: pointer;

    /* Transition très douce, pas trop agressive */
    transition: 
        background 0.35s ease,
        box-shadow 0.35s ease,
        border-color 0.35s ease,
        transform 0.20s ease;

    box-shadow: 0 4px 10px rgba(255, 0, 60, 0.25);
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Hover plus clair, plus doux, moins flashy */
.next-btn:hover {
    /* Rendu plus CLAIR */
    background: linear-gradient(135deg, #ff668a, #e60046);
    border-color: #ff6b82;

    /* Glow adouci */
    box-shadow: 0 0 14px rgba(255, 80, 120, 0.55);

    /* LÉGER scale (plus suave) */
    transform: scale(1.005);
}

/* Press (toujours important mais subtil) */
.next-btn:active {
    transform: scale(0.97);
    box-shadow: 0 0 8px rgba(255, 0, 60, 0.35);
}


            /* Animations LED du wrapper */
            @keyframes ledGradient {
                0% { background-position: 0% 50%; }
                50% { background-position: 100% 50%; }
                100% { background-position: 0% 50%; }
            }
            @keyframes ledPulse {
                0% { box-shadow: 0 0 40px rgba(255,0,60,0.3), 0 0 50px rgba(0,120,255,0.2); }
                50% { box-shadow: 0 0 50px rgba(255,0,60,0.5), 0 0 60px rgba(0,120,255,0.4); }
                100% { box-shadow: 0 0 40px rgba(255,0,60,0.3), 0 0 50px rgba(0,120,255,0.2); }
            }
        `;
                document.head.appendChild(style);
            }

            // Animation Entrée
            requestAnimationFrame(() => {
                modal.style.opacity = '1';
                wrapper.style.transform = 'scale(1)';
            });

            // --- LOGIQUE (Events) ---
            const btn = modalContent.querySelector('#roundNextBtn');

            // Gestion de la fermeture (avec animation de sortie)
            const handleClose = () => {
                // Animation de sortie
                wrapper.style.transform = 'scale(0.9)';
                modal.style.opacity = '0';
                setTimeout(() => {
                    modal.remove();
                    getCurrentState().racePaused = false;
                    saveRaceState();
                    if (onClose) onClose();
                }, 250);
            };

            btn.addEventListener('click', handleClose);

            // Click sur l'overlay
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    handleClose();
                }
            });
        }

        /* ---------- START / FLOW RACE (CORRIGÉ AVEC AUTO-RÉPARATION) ---------- */
        const startRaceBtn = document.getElementById('startRaceBtn');
        // On charge l'état au démarrage
        loadRaceState();

        startRaceBtn.addEventListener('click', () => {
            raceSerieVisible = !serieA.classList.contains('hidden') ? 'A' : 'B';
            const state = getCurrentState();

            // --- 1. AUTO-RÉPARATION (FIX DU BUG) ---
            // Si la Phase est "RACE" mais que le flag "finished" est faux (bug de synchro), on le force à TRUE.
            const phaseA = localStorage.getItem("fastway_phase_A");
            if (phaseA === "RACE" && localStorage.getItem("finishedA") !== "true") {
                console.log("Auto-repair: Phase A is RACE, forcing finishedA to true.");
                localStorage.setItem("finishedA", "true");
                finishedA = true; // Mise à jour variable locale
            }

            const phaseB = localStorage.getItem("fastway_phase_B");
            if (phaseB === "RACE" && localStorage.getItem("finishedB") !== "true") {
                console.log("Auto-repair: Phase B is RACE, forcing finishedB to true.");
                localStorage.setItem("finishedB", "true");
                finishedB = true; // Mise à jour variable locale
            }
            // ---------------------------------------

            // 2. Lecture de l'état qualif (Maintenant corrigé par l'étape 1)
            const isQualifADone = localStorage.getItem("finishedA") === "true";
            const isQualifBDone = localStorage.getItem("finishedB") === "true";

            // 3. Vérification stricte A et B
            if (!isQualifADone || !isQualifBDone) {
                let msg = "Impossible de lancer la course :<br><br>";
                if (!isQualifADone) msg += "<span style='color:#ff4444'>✖</span> La Qualification SÉRIE A n'est pas terminée.<br>";
                if (!isQualifBDone) msg += "<span style='color:#ff4444'>✖</span> La Qualification SÉRIE B n'est pas terminée.<br>";

                msg += "<br>Veuillez terminer toutes les qualifications.";
                // On utilise ta fonction showFastwayAlert si elle existe, sinon alert classique pour pas planter
                if (typeof showFastwayAlert === "function") {
                    showFastwayAlert(msg, "QUALIFICATIONS REQUISES");
                } else {
                    alert(msg.replace(/<br>/g, "\n").replace(/<[^>]*>/g, ""));
                }
                return;
            }

            // 4. Vérification Phase (Double sécurité)
            const currentPhase = localStorage.getItem("fastway_phase_" + raceSerieVisible);
            if (currentPhase && currentPhase !== "RACE") {
                const warningMsg = `La série ${raceSerieVisible} est encore en phase 'QUALIFICATION'.<br>Si vous venez de finir les qualifs, assurez-vous que la validation s'est bien faite.`;
                if (typeof showFastwayAlert === "function") showFastwayAlert(warningMsg, "MAUVAISE PHASE");
                else alert(warningMsg.replace(/<br>/g, "\n"));
                return;
            }

            // 5. Vérifications internes
            if (state.raceFinished) {
                const endMsg = 'La course est déjà terminée pour cette série.<br>Attendez la fin de l\'autre série pour relancer le cycle.';
                if (typeof showFastwayAlert === "function") showFastwayAlert(endMsg, "COURSE TERMINÉE");
                else alert(endMsg.replace(/<br>/g, "\n"));
                return;
            }

            // 6. Lancement
            if (state.racePaused && (state.currentDuels.length > 0 || state.raceQueue.length > 0 || state.raceWinners.length > 0)) {
                state.racePaused = false;
                saveRaceState();
                startRound();
                return;
            }

            if (state.raceQueue.length === 0 && state.currentDuels.length === 0 && state.raceWinners.length === 0) {
                const sortedCars = getLastTimesAndSort();
                state.raceQueue = sortedCars.map(c => c.name);
            }

            state.racePaused = false;
            saveRaceState();
            startRound();
        });

        function startRound() {
            const state = getCurrentState();
            saveRaceState();

            if (state.currentDuels.length > 0) {
                startNextDuel(state.currentDuels, currentRoundName, nextRoundName);
                return;
            }

            if (state.raceQueue.length === 1) {
                handleChampion(state.raceQueue[0]);
                return;
            }

            const duels = [];
            let carsCopy = [...state.raceQueue];

            if (carsCopy.length % 2 !== 0) {
                const freePass = carsCopy.shift();
                state.raceWinners.push(freePass);
            }

            while (carsCopy.length >= 2) {
                const fast = carsCopy.shift();
                const slow = carsCopy.pop();
                duels.push([fast, slow]);
            }

            state.currentDuels = duels;
            state.raceQueue = [];
            saveRaceState();
            startNextDuel(state.currentDuels, currentRoundName, nextRoundName);
        }

        // NOUVEAU CODE dans startRound() (assure que le nom du round est toujours défini)
        let currentRoundName = "Round " + (raceCount + 1); // Par défaut pour la saison régulière
        let nextRoundName = "Round " + (raceCount + 2);

        if (playoffState.active) {
            const currentStructure = PLAYOFF_STRUCTURE[playoffState.currentRoundIndex];
            currentRoundName = currentStructure.name;

            // Déterminer le nom du round suivant (pour les messages, même si on ne l'utilise pas pour le modal)
            if (playoffState.currentRoundIndex + 1 < PLAYOFF_STRUCTURE.length) {
                nextRoundName = PLAYOFF_STRUCTURE[playoffState.currentRoundIndex + 1].name;
            } else {
                nextRoundName = "FASTWAY FINAL";
            }
        }


        // 🛑 LIGNE MANQUANTE (L'en-tête de la fonction)
        function startNextDuel(duels, roundName, nextRoundName) {

            const state = getCurrentState();
            // state.currentDuels = duels; // Cette ligne est étrange ici mais nous la laissons si elle était là
            saveRaceState();

            if (state.racePaused) return; // ✅ Maintenant valide car à l'intérieur de la fonction !

            if (!duels || duels.length === 0) {
                // --- LOGIQUE FIN DE ROUND ---
                state.raceQueue = state.raceWinners;
                state.raceWinners = [];
                state.raceRound++;
                saveRaceState();

                if (state.raceQueue.length === 1) {
                    handleChampion(state.raceQueue[0]);
                    return;
                }

                const humanNext = nextRoundName ? `Prochain : ${nextRoundName}` : 'Prochaine manche';
                showRoundModal(`${roundName} terminé`, humanNext, () => {
                    saveRaceState();
                    startRound();
                });
                return;
            }

            // --- LOGIQUE DE DÉPART DE DUEL ---
            const duel = duels[0];
            if (!duel) {
                state.currentDuels = duels.filter(Boolean);
                saveRaceState();
                startNextDuel(state.currentDuels, roundName, nextRoundName);
                return;
            }

            const [car1, car2] = duel;
            // Appelle le modal avec le nom de round figé
            showDuelModal(car1, car2, roundName, (winner, manualTimeForWinner) => {

                // ... (logique du gagnant) ...

                state.raceWinners.push(winner);
                state.currentDuels.shift(); // retire duel terminé
                startNextDuel(state.currentDuels, roundName, nextRoundName); // Appel récursif

                saveRaceState();
                updateMainTable();
            });

            saveRaceState();
        }


        /* ---------- CHAMPION Modal FASTWAY Version (Course Gagnée) ---------- */
        function handleChampion(name) {
            const state = getCurrentState();
            state.raceFinished = true;
            saveRaceState();

            const row = findRowByName(name);
            if (row) {
                // L'incrémentation est conservée car c'est une STATISTIQUE cumulative,
                // même si le titre du modal est moins "définitif".
                incrementChampWinColumn(row);
            }

            // 1. Nettoyage
            document.querySelectorAll('.modal-overlay').forEach(m => m.remove());

            // 2. Overlay (identique aux autres modals)
            const modal = document.createElement('div');
            modal.className = "modal-overlay";
            Object.assign(modal.style, {
                position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)',
                display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 9999,
                backdropFilter: 'blur(10px)', opacity: '0', transition: 'opacity 0.3s ease'
            });

            // 3. Wrapper LED (Cadre animé OR et ROUGE)
            const wrapper = document.createElement('div');
            Object.assign(wrapper.style, {
                position: 'relative', borderRadius: '24px', padding: '5px', // padding plus épais
                background: 'linear-gradient(90deg, #FFD700, #ff003c, #FFD700)', // Or-Rouge-Or
                backgroundSize: '300% 300%',
                boxShadow: '0 0 50px rgba(255, 215, 0, 0.4), 0 0 70px rgba(255, 0, 60, 0.3)',
                animation: 'ledPulseGold 3.5s ease-in-out infinite, ledGradient 4s linear infinite',
                transform: 'scale(0.8)', transition: 'transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)'
            });

            // 4. Contenu
            const modalContent = document.createElement('div');
            Object.assign(modalContent.style, {
                background: '#111', borderRadius: '21px', padding: '40px 50px',
                width: '450px', maxWidth: '90vw',
                fontFamily: "'Poppins', sans-serif", color: '#fff', textAlign: 'center',
                position: 'relative'
            });

            // MODIFICATIONS CLÉS CI-DESSOUS
            modalContent.innerHTML = `
        <span class="flag-icon">🏁</span>
        <h2 class="race-win-title" style="margin:10px 0 10px;">
            VICTOIRE DE LA COURSE ${raceSerieVisible}
        </h2>
        <p class="champ-name">${name}</p>
        <p style="margin-bottom: 30px; font-size: 16px; color: #ccc;">
            Le vainqueur du week-end ! Félicitations pour cette performance.
        </p>
        
        <div class="modal-buttons">
            <button id="champClose" class="champ-close-btn">
                FERMER
            </button>
        </div>
    `;

            wrapper.appendChild(modalContent);
            modal.appendChild(wrapper);
            document.body.appendChild(modal);

            // --- STYLES CSS INJECTÉS (Mise à jour pour les titres) ---
            const styleId = "champion-modal-styles-v2"; // Nouvelle version de style
            if (!document.getElementById(styleId)) {
                const style = document.createElement('style');
                style.id = styleId;
                style.textContent = `
            /* Titre Victoire de Course (Remplace .champ-title) */
            .race-win-title { 
                font-weight: 900; 
                letter-spacing: 2px; 
                font-size: 20px; 
                text-transform: uppercase; 
                color: #ff003c; /* Rouge FASTWAY */
                text-shadow: 0 0 10px rgba(255, 0, 60, 0.5);
                margin-bottom: 25px;
            }

            /* Nom du Vainqueur (Identique) */
            .champ-name {
                font-size: 38px;
                font-weight: 900;
                color: #FFD700; /* Or */
                text-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
                text-transform: uppercase;
                letter-spacing: 3px;
                margin-bottom: 40px;
                animation: pulseName 1s infinite alternate;
            }

            /* Icône Drapeau (Remplace .trophy-icon) */
            .flag-icon {
                font-size: 60px;
                display: block;
                margin: 0 auto 10px;
                filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
            }

            /* Bouton Fermer (Style plus simple - Identique) */
            .champ-close-btn {
                padding: 10px 30px;
                background: #333;
                border: 2px solid #555;
                border-radius: 8px;
                color: #fff;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .champ-close-btn:hover { 
                background: #ff003c; 
                border-color: #ff003c;
                box-shadow: 0 0 15px rgba(255, 0, 60, 0.4); 
            }
            .champ-close-btn:active { transform: scale(0.98); }


            /* Animations (Identiques) */
            @keyframes pulseName {
                0% { transform: scale(1); opacity: 1; }
                100% { transform: scale(1.02); opacity: 0.95; }
            }
            @keyframes ledPulseGold {
                0% { box-shadow: 0 0 50px rgba(255, 215, 0, 0.4), 0 0 70px rgba(255, 0, 60, 0.3); }
                50% { box-shadow: 0 0 60px rgba(255, 215, 0, 0.7), 0 0 80px rgba(255, 0, 60, 0.5); }
                100% { box-shadow: 0 0 50px rgba(255, 215, 0, 0.4), 0 0 70px rgba(255, 0, 60, 0.3); }
            }
            @keyframes ledGradient {
                0% { background-position: 0% 50%; }
                50% { background-position: 100% 50%; }
                100% { background-position: 0% 50%; }
            }
        `;
                document.head.appendChild(style);
            }

            // Animation Entrée
            requestAnimationFrame(() => {
                modal.style.opacity = '1';
                wrapper.style.transform = 'scale(1)';
            });


            // --- LOGIQUE (Events) ---
            const handleClose = () => {
                // Animation de sortie
                wrapper.style.transform = 'scale(0.8)';
                modal.style.opacity = '0';
                setTimeout(() => {
                    modal.remove();
                    saveRaceState();
                    if (typeof updateMainTable === 'function') updateMainTable();
                    endRace(raceSerieVisible); // C'est ici qu'on termine le cycle !
                }, 400); // Temps plus long pour la transition plus lente
            };

            modalContent.querySelector('#champClose').addEventListener('click', handleClose);

            modal.addEventListener('click', e => {
                if (e.target === modal) {
                    handleClose();
                }
            });
        }

        /* ---------- normalizeTime (strict) ---------- */
        function normalizeTime(rawTime) {
            if (!rawTime) return "";
            let t = String(rawTime).trim().replace(",", ".");

            // Si format 2 chiffres + . + 3 chiffres et commence par 0, enlever le 0 de tête
            if (/^\d{2}\.\d{3}$/.test(t) && t.startsWith("0")) {
                t = t.substring(1);
            }

            // N'accepte que 1 ou 2 chiffres avant la virgule + 3 chiffres après la virgule
            if (!/^\d{1,2}\.\d{3}$/.test(t)) return "";
            return t;
        }

        /* ---------- Duel modal FASTWAY Final Version (Fix du Sizing) ---------- */
        function showDuelModal(car1, car2, fixedRoundName, onWinnerSelected) {
            // 1. Nettoyage
            document.querySelectorAll('.modal-overlay').forEach(m => m.remove());

            // 2. Overlay
            const modal = document.createElement('div');
            modal.className = "modal-overlay";
            Object.assign(modal.style, {
                position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)',
                display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 9999,
                backdropFilter: 'blur(10px)', opacity: '0', transition: 'opacity 0.3s ease'
            });

            // 3. Wrapper LED (Le cadre animé)
            const wrapper = document.createElement('div');
            Object.assign(wrapper.style, {
                position: 'relative', borderRadius: '24px', padding: '3px',
                background: 'linear-gradient(90deg, #ff003c, #0077ff, #ff003c)', backgroundSize: '300% 300%',
                boxShadow: '0 0 40px rgba(255,0,60,0.3), 0 0 50px rgba(0,120,255,0.2)',
                animation: 'ledPulse 3.5s ease-in-out infinite, ledGradient 4s linear infinite',
                transform: 'scale(0.9)', transition: 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)'
            });

            // 4. Contenu
            const modalContent = document.createElement('div');
            Object.assign(modalContent.style, {
                background: '#111', borderRadius: '21px', padding: '25px',
                minWidth: '500px', maxWidth: '90vw',
                fontFamily: "'Poppins', sans-serif", color: '#fff', textAlign: 'center',
                position: 'relative'
            });

            modalContent.innerHTML = `
    <h2 style="margin:0 0 10px; font-weight:900; letter-spacing:2px; font-size:24px; text-transform:uppercase; color:#fff;">
        DUEL
    </h2>
    <p id="roundName" style="margin:0 0 20px; font-weight:700; font-size:18px; text-transform:uppercase; letter-spacing:1px;">
      ${fixedRoundName}
    </p>

    <div style="display:flex; align-items: flex-start; gap: 15px; margin-bottom: 20px; position: relative;">

      <div style="flex:1; position:relative;">
        <div style="position:relative;">
            <button id="btn1" class="carBtn redBtn">${car1}</button>
            <button id="toggleManual1" class="lightning-btn">⚡</button>
        </div>
        <div id="manual1" class="manual-container">
           <input id="time1" placeholder="00.000" class="time-input red-input">
        </div>
      </div>

      <div style="font-weight:900; font-size:22px; color:#ddd; padding-top: 15px; text-shadow: 0 2px 5px rgba(0,0,0,0.5);">VS</div>

      <div style="flex:1; position:relative;">
        <div style="position:relative;">
            <button id="btn2" class="carBtn blueBtn">${car2}</button>
            <button id="toggleManual2" class="lightning-btn">⚡</button>
        </div>
        <div id="manual2" class="manual-container">
           <input id="time2" placeholder="00.000" class="time-input blue-input">
        </div>
      </div>
    </div>

    <div>
      <button id="duelCancelBtn" class="cancel-btn">Annuler</button>
    </div>
  `;

            wrapper.appendChild(modalContent);
            modal.appendChild(wrapper);
            document.body.appendChild(modal);

            // --- CSS STYLES (MIS À JOUR) ---
            const styleId = "duel-modal-styles-v4"; // ID mis à jour pour s'assurer que le nouveau style est appliqué
            if (!document.getElementById(styleId)) {
                const style = document.createElement('style');
                style.id = styleId;
                style.textContent = `
        /* Boutons Voitures (Hover plus subtil) */
        .carBtn {
            width: 100%; padding: 15px 10px; border-radius: 12px; border: none;
            color: #fff; font-weight: 700; cursor: pointer; font-size: 16px;
            transition: all 0.2s ease-in-out; position: relative; z-index: 1;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .carBtn:hover { transform: translateY(-2px) scale(1.02); filter: brightness(1.1); }
        .carBtn:active { transform: translateY(0); }

        .redBtn { background: linear-gradient(135deg, #ff003c, #b3002a); }
        .redBtn:hover { box-shadow: 0 5px 15px rgba(255, 0, 60, 0.4); }

        .blueBtn { background: linear-gradient(135deg, #0077ff, #004ca3); }
        .blueBtn:hover { box-shadow: 0 5px 15px rgba(0, 119, 255, 0.4); }

        /* Bouton Éclair ⚡ */
        .lightning-btn {
            position: absolute; top: -10px; right: -5px; z-index: 10;
            width: 30px; height: 30px; border: none; 
            background: transparent; 
            color: #ffea00; font-size: 22px; cursor: pointer;
            transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5));
        }
        .lightning-btn:hover { 
            color: #fff; 
            text-shadow: 0 0 10px #ffea00, 0 0 20px #ffea00;
            transform: scale(1.1) rotate(5deg); 
        }

        /* Conteneur Saisie Manuelle (Slide-Down) */
        .manual-container {
            max-height: 0; overflow: hidden; opacity: 0;
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            margin-top: 0;
        }
        .manual-container.open {
            max-height: 70px; opacity: 1; margin-top: 12px;
        }

        /* Inputs Temps (CORRECTION APPORTÉE ICI) */
        .time-input {
            width: 100%; 
            box-sizing: border-box; /* <-- LA CORRECTION */
            padding: 8px; border-radius: 8px; background: #0a0a0a;
            border: 2px solid #333; color: #fff; font-family: 'Courier New', monospace;
            font-size: 16px; text-align: center; outline: none; transition: 0.3s;
        }
        .red-input:focus { border-color: #ff003c; box-shadow: 0 0 15px rgba(255,0,60,0.3); }
        .blue-input:focus { border-color: #0077ff; box-shadow: 0 0 15px rgba(0,119,255,0.3); }

        /* Bouton Annuler */
        .cancel-btn {
            padding: 8px 20px; border: 2px solid #333; border-radius: 20px;
            background: transparent; color: #888; cursor: pointer; font-weight: 600;
            font-size: 13px; text-transform: uppercase; transition: 0.2s;
        }
        .cancel-btn:hover { border-color: #666; color: #fff; background: #222; }
      `;
                document.head.appendChild(style);
            }

            // Animation Entrée
            requestAnimationFrame(() => {
                modal.style.opacity = '1';
                wrapper.style.transform = 'scale(1)';
            });

            // --- LOGIQUE ---
            const roundNameEl = modalContent.querySelector('#roundName');

            // Coloration du Round Name
            function styleRound(roundText) {
                const t = String(roundText || '').trim();
                let color = '#FFD700';
                if (/(^|\b)(demi|quart|semi)/i.test(t)) color = '#00E5FF';
                else if (/\bfinale\b/i.test(t)) {
                    color = '#FF003C';
                    roundNameEl.style.textShadow = '0 0 15px rgba(255,0,60,0.5)';
                }
                roundNameEl.style.color = color;
            }
            styleRound(fixedRoundName);

            // Toggle Inputs Manuels
            const setupToggle = (btnId, divId) => {
                const btn = modalContent.querySelector(btnId);
                const div = modalContent.querySelector(divId);
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    div.classList.toggle('open');
                    const input = div.querySelector('input');
                    if (div.classList.contains('open')) setTimeout(() => input.focus(), 100);
                });
                div.addEventListener('click', e => e.stopPropagation());
            };

            setupToggle('#toggleManual1', '#manual1');
            setupToggle('#toggleManual2', '#manual2');

            const input1 = modalContent.querySelector('#time1');
            const input2 = modalContent.querySelector('#time2');

            // Sélection du gagnant
            function pickWinner(name) {
                const raw1 = input1.value.trim();
                const raw2 = input2.value.trim();
                const norm1 = raw1 ? normalizeTime(raw1) : "";
                const norm2 = raw2 ? normalizeTime(raw2) : "";

                const alertFunc = (typeof showFastwayAlert === 'function') ? showFastwayAlert : alert;

                if (raw1 && !norm1) { alertFunc(`Temps invalide pour ${car1}.<br>Format requis : 00.000`, "ERREUR FORMAT"); return; }
                if (raw2 && !norm2) { alertFunc(`Temps invalide pour ${car2}.<br>Format requis : 00.000`, "ERREUR FORMAT"); return; }

                if (norm1) { const row1 = findRowByName(car1); if (row1) updateRowTimeAndMaybeBest(row1, norm1); }
                if (norm2) { const row2 = findRowByName(car2); if (row2) updateRowTimeAndMaybeBest(row2, norm2); }

                if (typeof updateMainTable === 'function') updateMainTable();
                saveRaceState();


                // Animation de sortie
                wrapper.style.transform = 'scale(0.9)';
                modal.style.opacity = '0';
                setTimeout(() => {
                    modal.remove();
                    onWinnerSelected(name, { [car1]: norm1 || null, [car2]: norm2 || null });
                }, 250);
            }

            modalContent.querySelector('#btn1').addEventListener('click', () => pickWinner(car1));
            modalContent.querySelector('#btn2').addEventListener('click', () => pickWinner(car2));

            const closeModal = () => {
                modal.style.opacity = '0';
                wrapper.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    modal.remove();
                    getCurrentState().racePaused = true;
                    saveRaceState();
                }, 250);
            };

            modalContent.querySelector('#duelCancelBtn').addEventListener('click', closeModal);
            modal.addEventListener('click', e => { if (e.target === modal) closeModal(); });
        }


        /* ---------- Nettoyage / nouvelle série ---------- */
        function resetRaceState() {
            const state = getCurrentState();
            state.racePaused = false;
            state.raceRound = 1;
            state.raceQueue = [];
            state.raceWinners = [];
            state.currentDuels = [];
            state.raceFinished = false;
            saveRaceState();
            if (typeof updateMainTable === 'function') updateMainTable();
        }

        window.addEventListener("load", () => {
            loadRaceState();

            function syncStateFromDom() {
                const allRows = getAllSerieRows();

                allRows.forEach(row => {
                    const name = (row.children[2]?.textContent || '').trim();
                    if (!name) return;

                    // Déterminer de quelle série provient la row (A ou B)
                    // On suppose que serieA et serieB sont des références DOM aux conteneurs de chaque série
                    let seriesKey = 'A';
                    if (serieB && serieB.contains(row)) seriesKey = 'B';
                    else if (serieA && serieA.contains(row)) seriesKey = 'A';

                    const state = raceStates[seriesKey];
                    if (!state) {
                        // fallback : créer si absent
                        raceStates[seriesKey] = { carStats: {} };
                    }
                    if (!raceStates[seriesKey].carStats) raceStates[seriesKey].carStats = {};

                    // Lire wins de la DOM
                    let winFromDom = 0;
                    if (typeof COL_WIN !== 'undefined' && row.children[COL_WIN]) {
                        winFromDom = parseInt(row.children[COL_WIN].textContent || '0', 10) || 0;
                    } else {
                        const el = row.querySelector('.win');
                        if (el) winFromDom = parseInt(el.textContent || '0', 10) || 0;
                    }

                    // Lire losses depuis l'état (s'il existe)
                    let lossFromState = (raceStates[seriesKey].carStats[name] && parseInt(raceStates[seriesKey].carStats[name].losses || 0, 10)) || 0;

                    // Mettre à jour l'état pour cette voiture dans la série correcte
                    if (!raceStates[seriesKey].carStats[name]) {
                        raceStates[seriesKey].carStats[name] = { wins: winFromDom, losses: lossFromState };
                    } else {
                        raceStates[seriesKey].carStats[name].wins = winFromDom;
                        raceStates[seriesKey].carStats[name].losses = lossFromState;
                    }

                    // Utiliser explicitState pour forcer la lecture dans la série correcte
                    updateWinPercentage(row, raceStates[seriesKey]);
                });

                saveRaceState();
            }

            // Appelle la sync après le chargement de la page
            syncStateFromDom();


            setTimeout(() => {
                Object.entries(getCurrentState().bestTimes).forEach(([name, time]) => {
                    // Debug only
                });
            }, 500);

            // Vérifie quelle série est visible (A ou B)
            raceSerieVisible = !serieA.classList.contains('hidden') ? 'A' : 'B';

            // Applique les meilleurs temps sauvegardés après un léger délai
            setTimeout(() => {
                applySavedBestTimes();
            }, 100);

            setTimeout(() => {
                const allRows = getAllSerieRows(); // toutes les lignes A + B
                allRows.forEach(row => {
                    const name = (row.children[2]?.textContent || '').trim();
                    if (!name) return;

                    // déterminer série
                    let seriesKey = 'A';
                    if (serieB && serieB.contains(row)) seriesKey = 'B';
                    else if (serieA && serieA.contains(row)) seriesKey = 'A';

                    if (!raceStates[seriesKey].carStats) raceStates[seriesKey].carStats = {};
                    if (!raceStates[seriesKey].carStats[name]) raceStates[seriesKey].carStats[name] = { wins: 0, losses: 0 };

                    updateWinPercentage(row, raceStates[seriesKey]);
                });
            }, 300);

        });


        /* Exports pour debug */
        window.fastwayRace = {
            startRound,
            startNextDuel,
            resetRaceState,
            saveRaceState,
            loadRaceState
        };


    </script>

</body>

</html>